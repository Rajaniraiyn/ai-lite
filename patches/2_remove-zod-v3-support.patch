From 70e352a97bf6938453014a93403707e84319aafc Mon Sep 17 00:00:00 2001
From: Rajaniraiyn R <rajaniraiyn@gmail.com>
Date: Wed, 28 Jan 2026 15:37:25 +0530
Subject: [PATCH] patch: remove-zod-v3-support

---
 .../ai/src/agent/tool-loop-agent.test-d.ts    |   2 +-
 .../src/generate-text/generate-text.test-d.ts |   2 +-
 .../src/generate-text/stream-text.test-d.ts   |   2 +-
 packages/devtools/examples/basic/tools.ts     |   2 +-
 .../gateway/src/tool/perplexity-search.ts     |   2 +-
 packages/provider-utils/package.json          |   2 +-
 packages/provider-utils/src/schema.ts         |  48 +-
 .../zod3-to-json-schema/LICENSE               |  16 -
 .../zod3-to-json-schema/README.md             |  24 -
 .../zod3-to-json-schema/get-relative-path.ts  |   7 -
 .../zod3-to-json-schema/index.ts              |   1 -
 .../zod3-to-json-schema/options.ts            |  98 --
 .../zod3-to-json-schema/parse-def.test.ts     | 224 -----
 .../zod3-to-json-schema/parse-def.ts          | 109 ---
 .../zod3-to-json-schema/parse-types.ts        |  57 --
 .../zod3-to-json-schema/parsers/any.ts        |   5 -
 .../zod3-to-json-schema/parsers/array.test.ts |  98 --
 .../zod3-to-json-schema/parsers/array.ts      |  38 -
 .../parsers/bigint.test.ts                    |  51 -
 .../zod3-to-json-schema/parsers/bigint.ts     |  44 -
 .../zod3-to-json-schema/parsers/boolean.ts    |   7 -
 .../parsers/branded.test.ts                   |  16 -
 .../zod3-to-json-schema/parsers/branded.ts    |   7 -
 .../zod3-to-json-schema/parsers/catch.test.ts |  15 -
 .../zod3-to-json-schema/parsers/catch.ts      |   7 -
 .../zod3-to-json-schema/parsers/date.test.ts  |  97 --
 .../zod3-to-json-schema/parsers/date.ts       |  64 --
 .../parsers/default.test.ts                   |  54 -
 .../zod3-to-json-schema/parsers/default.ts    |  14 -
 .../parsers/effects.test.ts                   |  41 -
 .../zod3-to-json-schema/parsers/effects.ts    |  14 -
 .../zod3-to-json-schema/parsers/enum.ts       |  13 -
 .../parsers/intersection.test.ts              |  92 --
 .../parsers/intersection.ts                   |  52 -
 .../zod3-to-json-schema/parsers/literal.ts    |  29 -
 .../zod3-to-json-schema/parsers/map.test.ts   |  48 -
 .../zod3-to-json-schema/parsers/map.ts        |  47 -
 .../parsers/native-enum.test.ts               | 102 --
 .../parsers/native-enum.ts                    |  31 -
 .../zod3-to-json-schema/parsers/never.ts      |   9 -
 .../zod3-to-json-schema/parsers/null.ts       |   9 -
 .../parsers/nullable.test.ts                  |  67 --
 .../zod3-to-json-schema/parsers/nullable.ts   |  42 -
 .../parsers/number.test.ts                    |  65 --
 .../zod3-to-json-schema/parsers/number.ts     |  44 -
 .../parsers/object.test.ts                    | 149 ---
 .../zod3-to-json-schema/parsers/object.ts     |  88 --
 .../parsers/optional.test.ts                  | 147 ---
 .../zod3-to-json-schema/parsers/optional.ts   |  23 -
 .../zod3-to-json-schema/parsers/pipe.test.ts  |  35 -
 .../zod3-to-json-schema/parsers/pipeline.ts   |  29 -
 .../parsers/promise.test.ts                   |  15 -
 .../zod3-to-json-schema/parsers/promise.ts    |  11 -
 .../parsers/readonly.test.ts                  |  20 -
 .../zod3-to-json-schema/parsers/readonly.ts   |   7 -
 .../parsers/record.test.ts                    | 108 --
 .../zod3-to-json-schema/parsers/record.ts     |  71 --
 .../zod3-to-json-schema/parsers/set.test.ts   |  20 -
 .../zod3-to-json-schema/parsers/set.ts        |  35 -
 .../parsers/string.test.ts                    | 438 ---------
 .../zod3-to-json-schema/parsers/string.ts     | 426 --------
 .../zod3-to-json-schema/parsers/tuple.test.ts |  33 -
 .../zod3-to-json-schema/parsers/tuple.ts      |  61 --
 .../zod3-to-json-schema/parsers/undefined.ts  |  11 -
 .../zod3-to-json-schema/parsers/union.test.ts | 226 -----
 .../zod3-to-json-schema/parsers/union.ts      | 144 ---
 .../zod3-to-json-schema/parsers/unknown.ts    |   7 -
 .../zod3-to-json-schema/refs.test.ts          | 919 ------------------
 .../zod3-to-json-schema/refs.ts               |  39 -
 .../zod3-to-json-schema/select-parser.ts      | 115 ---
 .../zod3-to-json-schema.test.ts               | 862 ----------------
 .../zod3-to-json-schema.ts                    |  93 --
 packages/rsc/src/stream-ui/stream-ui.tsx      |   7 +-
 73 files changed, 13 insertions(+), 5944 deletions(-)
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/LICENSE
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/README.md
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/get-relative-path.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/index.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/options.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-types.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/any.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/enum.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/literal.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/never.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/null.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipe.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/select-parser.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.test.ts
 delete mode 100644 packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts

diff --git a/packages/ai/src/agent/tool-loop-agent.test-d.ts b/packages/ai/src/agent/tool-loop-agent.test-d.ts
index 5ddb365..cb5d066 100644
--- a/packages/ai/src/agent/tool-loop-agent.test-d.ts
+++ b/packages/ai/src/agent/tool-loop-agent.test-d.ts
@@ -1,5 +1,5 @@
 import { describe, expectTypeOf, it } from 'vitest';
-import { z } from 'zod';
+import { z } from 'zod/v4';
 import { Output } from '../generate-text';
 import { MockLanguageModelV3 } from '../test/mock-language-model-v3';
 import { AsyncIterableStream } from '../util/async-iterable-stream';
diff --git a/packages/ai/src/generate-text/generate-text.test-d.ts b/packages/ai/src/generate-text/generate-text.test-d.ts
index 13ea829..5a31972 100644
--- a/packages/ai/src/generate-text/generate-text.test-d.ts
+++ b/packages/ai/src/generate-text/generate-text.test-d.ts
@@ -1,6 +1,6 @@
 import { JSONValue } from '@ai-sdk/provider';
 import { describe, expectTypeOf, it } from 'vitest';
-import { z } from 'zod';
+import { z } from 'zod/v4';
 import { generateText, Output } from '../generate-text';
 import { MockLanguageModelV3 } from '../test/mock-language-model-v3';
 
diff --git a/packages/ai/src/generate-text/stream-text.test-d.ts b/packages/ai/src/generate-text/stream-text.test-d.ts
index 945b543..7b803c6 100644
--- a/packages/ai/src/generate-text/stream-text.test-d.ts
+++ b/packages/ai/src/generate-text/stream-text.test-d.ts
@@ -1,6 +1,6 @@
 import { JSONValue } from '@ai-sdk/provider';
 import { describe, expectTypeOf, it } from 'vitest';
-import { z } from 'zod';
+import { z } from 'zod/v4';
 import { Output, streamText } from '../generate-text';
 import { MockLanguageModelV3 } from '../test/mock-language-model-v3';
 import { AsyncIterableStream } from '../util';
diff --git a/packages/devtools/examples/basic/tools.ts b/packages/devtools/examples/basic/tools.ts
index f39f71a..26eca82 100644
--- a/packages/devtools/examples/basic/tools.ts
+++ b/packages/devtools/examples/basic/tools.ts
@@ -1,5 +1,5 @@
 import { tool } from 'ai';
-import { z } from 'zod';
+import { z } from 'zod/v4';
 
 export const tools = {
   weather: tool({
diff --git a/packages/gateway/src/tool/perplexity-search.ts b/packages/gateway/src/tool/perplexity-search.ts
index e315e42..9492fe9 100644
--- a/packages/gateway/src/tool/perplexity-search.ts
+++ b/packages/gateway/src/tool/perplexity-search.ts
@@ -3,7 +3,7 @@ import {
   lazySchema,
   zodSchema,
 } from '@ai-sdk/provider-utils';
-import { z } from 'zod';
+import { z } from 'zod/v4';
 
 export interface PerplexitySearchConfig {
   /**
diff --git a/packages/provider-utils/package.json b/packages/provider-utils/package.json
index d51423f..0a14cc1 100644
--- a/packages/provider-utils/package.json
+++ b/packages/provider-utils/package.json
@@ -59,7 +59,7 @@
     "zod": "3.25.76"
   },
   "peerDependencies": {
-    "zod": "^3.25.76 || ^4.1.8"
+    "zod": "^4.1.8"
   },
   "engines": {
     "node": ">=18"
diff --git a/packages/provider-utils/src/schema.ts b/packages/provider-utils/src/schema.ts
index 74064de..41f3b43 100644
--- a/packages/provider-utils/src/schema.ts
+++ b/packages/provider-utils/src/schema.ts
@@ -1,9 +1,7 @@
 import { JSONSchema7, TypeValidationError } from '@ai-sdk/provider';
 import { StandardSchemaV1, StandardJSONSchemaV1 } from '@standard-schema/spec';
-import * as z3 from 'zod/v3';
 import * as z4 from 'zod/v4';
 import { addAdditionalPropertiesToJsonSchema } from './add-additional-properties-to-json-schema';
-import { zod3ToJsonSchema } from './to-json-schema/zod3-to-json-schema';
 
 /**
  * Used to mark schemas so we can support both Zod and custom schemas.
@@ -62,9 +60,7 @@ export function lazySchema<SCHEMA>(
 
 export type LazySchema<SCHEMA> = () => Schema<SCHEMA>;
 
-export type ZodSchema<SCHEMA = any> =
-  | z3.Schema<SCHEMA, z3.ZodTypeDef, any>
-  | z4.core.$ZodType<SCHEMA, any>;
+export type ZodSchema<SCHEMA = any> = z4.core.$ZodType<SCHEMA, any>;
 
 export type StandardSchema<SCHEMA = any> = StandardSchemaV1<unknown, SCHEMA> &
   StandardJSONSchemaV1<unknown, SCHEMA>;
@@ -170,39 +166,7 @@ function standardSchema<OBJECT>(
   );
 }
 
-export function zod3Schema<OBJECT>(
-  zodSchema: z3.Schema<OBJECT, z3.ZodTypeDef, any>,
-  options?: {
-    /**
-     * Enables support for references in the schema.
-     * This is required for recursive schemas, e.g. with `z.lazy`.
-     * However, not all language models and providers support such references.
-     * Defaults to `false`.
-     */
-    useReferences?: boolean;
-  },
-): Schema<OBJECT> {
-  // default to no references (to support openapi conversion for google)
-  const useReferences = options?.useReferences ?? false;
-
-  return jsonSchema(
-    // defer json schema creation to avoid unnecessary computation when only validation is needed
-    () =>
-      zod3ToJsonSchema(zodSchema, {
-        $refStrategy: useReferences ? 'root' : 'none',
-      }) as JSONSchema7,
-    {
-      validate: async value => {
-        const result = await zodSchema.safeParseAsync(value);
-        return result.success
-          ? { success: true, value: result.data }
-          : { success: false, error: result.error };
-      },
-    },
-  );
-}
-
-export function zod4Schema<OBJECT>(
+function zod4Schema<OBJECT>(
   zodSchema: z4.core.$ZodType<OBJECT, any>,
   options?: {
     /**
@@ -239,16 +203,14 @@ export function zod4Schema<OBJECT>(
 }
 
 export function isZod4Schema(
-  zodSchema: z4.core.$ZodType<any, any> | z3.Schema<any, z3.ZodTypeDef, any>,
+  zodSchema: z4.core.$ZodType<any, any>,
 ): zodSchema is z4.core.$ZodType<any, any> {
   // https://zod.dev/library-authors?id=how-to-support-zod-3-and-zod-4-simultaneously
   return '_zod' in zodSchema;
 }
 
 export function zodSchema<OBJECT>(
-  zodSchema:
-    | z4.core.$ZodType<OBJECT, any>
-    | z3.Schema<OBJECT, z3.ZodTypeDef, any>,
+  zodSchema: z4.core.$ZodType<OBJECT, any>,
   options?: {
     /**
      * Enables support for references in the schema.
@@ -262,6 +224,6 @@ export function zodSchema<OBJECT>(
   if (isZod4Schema(zodSchema)) {
     return zod4Schema(zodSchema, options);
   } else {
-    return zod3Schema(zodSchema, options);
+    throw new Error('Only Zod v4 schemas are supported.');
   }
 }
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/LICENSE b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/LICENSE
deleted file mode 100644
index b3b48f8..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/LICENSE
+++ /dev/null
@@ -1,16 +0,0 @@
-ISC License
-
-Copyright (c) 2020, Stefan Terdell
-Copyright (c) 2025, Vercel Inc.
-
-Permission to use, copy, modify, and/or distribute this software for any
-purpose with or without fee is hereby granted, provided that the above
-copyright notice and this permission notice appear in all copies.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
\ No newline at end of file
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/README.md b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/README.md
deleted file mode 100644
index ed978d3..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/README.md
+++ /dev/null
@@ -1,24 +0,0 @@
-# `zod-to-json-schema`
-
-Originally copied from https://github.com/StefanTerdell/zod-to-json-schema because its `peerDependency` on `"zod": "^3.24.1"` while `ai` needs to support `zod@4` if users already use it. We want to avoid having both `zod@3` and `zod@4` in the dependency tree of our users.
-
-The code in this directory and sub-directories is released under the ISC license:
-
-```
-ISC License
-
-Copyright (c) 2020, Stefan Terdell
-Copyright (c) 2025, Vercel Inc.
-
-Permission to use, copy, modify, and/or distribute this software for any
-purpose with or without fee is hereby granted, provided that the above
-copyright notice and this permission notice appear in all copies.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-```
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/get-relative-path.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/get-relative-path.ts
deleted file mode 100644
index cf80a29..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/get-relative-path.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-export const getRelativePath = (pathA: string[], pathB: string[]) => {
-  let i = 0;
-  for (; i < pathA.length && i < pathB.length; i++) {
-    if (pathA[i] !== pathB[i]) break;
-  }
-  return [(pathA.length - i).toString(), ...pathB.slice(i)].join('/');
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/index.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/index.ts
deleted file mode 100644
index 1d4d8a5..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/index.ts
+++ /dev/null
@@ -1 +0,0 @@
-export { zod3ToJsonSchema } from './zod3-to-json-schema';
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/options.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/options.ts
deleted file mode 100644
index ab5b031..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/options.ts
+++ /dev/null
@@ -1,98 +0,0 @@
-import { ZodSchema, ZodTypeDef } from 'zod/v3';
-import { Refs, Seen } from './refs';
-import { JsonSchema7Type } from './parse-types';
-
-export type DateStrategy =
-  | 'format:date-time'
-  | 'format:date'
-  | 'string'
-  | 'integer';
-
-export const ignoreOverride = Symbol(
-  'Let zodToJsonSchema decide on which parser to use',
-);
-
-export type OverrideCallback = (
-  def: ZodTypeDef,
-  refs: Refs,
-  seen: Seen | undefined,
-  forceResolution?: boolean,
-) => JsonSchema7Type | undefined | typeof ignoreOverride;
-
-export type PostProcessCallback = (
-  jsonSchema: JsonSchema7Type | undefined,
-  def: ZodTypeDef,
-  refs: Refs,
-) => JsonSchema7Type | undefined;
-
-export const jsonDescription: PostProcessCallback = (jsonSchema, def) => {
-  if (def.description) {
-    try {
-      return {
-        ...jsonSchema,
-        ...JSON.parse(def.description),
-      };
-    } catch {}
-  }
-
-  return jsonSchema;
-};
-
-export type Options = {
-  name: string | undefined;
-  $refStrategy: 'root' | 'relative' | 'none' | 'seen';
-  basePath: string[];
-  effectStrategy: 'input' | 'any';
-  pipeStrategy: 'input' | 'output' | 'all';
-  dateStrategy: DateStrategy | DateStrategy[];
-  mapStrategy: 'entries' | 'record';
-  removeAdditionalStrategy: 'passthrough' | 'strict';
-  allowedAdditionalProperties: true | undefined;
-  rejectedAdditionalProperties: false | undefined;
-  strictUnions: boolean;
-  definitionPath: string;
-  definitions: Record<string, ZodSchema>;
-  errorMessages: boolean;
-  patternStrategy: 'escape' | 'preserve';
-  applyRegexFlags: boolean;
-  emailStrategy: 'format:email' | 'format:idn-email' | 'pattern:zod';
-  base64Strategy: 'format:binary' | 'contentEncoding:base64' | 'pattern:zod';
-  nameStrategy: 'ref' | 'title';
-  override?: OverrideCallback;
-  postProcess?: PostProcessCallback;
-};
-
-export const defaultOptions: Options = {
-  name: undefined,
-  $refStrategy: 'root',
-  basePath: ['#'],
-  effectStrategy: 'input',
-  pipeStrategy: 'all',
-  dateStrategy: 'format:date-time',
-  mapStrategy: 'entries',
-  removeAdditionalStrategy: 'passthrough',
-  allowedAdditionalProperties: true,
-  rejectedAdditionalProperties: false,
-  definitionPath: 'definitions',
-  strictUnions: false,
-  definitions: {},
-  errorMessages: false,
-  patternStrategy: 'escape',
-  applyRegexFlags: false,
-  emailStrategy: 'format:email',
-  base64Strategy: 'contentEncoding:base64',
-  nameStrategy: 'ref',
-};
-
-export const getDefaultOptions = (
-  options: Partial<Options> | string | undefined,
-) =>
-  (typeof options === 'string'
-    ? {
-        ...defaultOptions,
-        name: options,
-      }
-    : {
-        ...defaultOptions,
-        ...options,
-      }) as Options;
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.test.ts
deleted file mode 100644
index e7dd0b8..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.test.ts
+++ /dev/null
@@ -1,224 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseDef } from './parse-def';
-import { getRefs } from './refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('parseDef', () => {
-  it('should return a proper json schema with some common types without validation', () => {
-    const zodSchema = z.object({
-      requiredString: z.string(),
-      optionalString: z.string().optional(),
-      literalString: z.literal('literalStringValue'),
-      stringArray: z.array(z.string()),
-      stringEnum: z.enum(['stringEnumOptionA', 'stringEnumOptionB']),
-      tuple: z.tuple([z.string(), z.number(), z.boolean()]),
-      record: z.record(z.boolean()),
-      requiredNumber: z.number(),
-      optionalNumber: z.number().optional(),
-      numberOrNull: z.number().nullable(),
-      numberUnion: z.union([z.literal(1), z.literal(2), z.literal(3)]),
-      mixedUnion: z.union([
-        z.literal('abc'),
-        z.literal(123),
-        z.object({ nowItGetsAnnoying: z.literal(true) }),
-      ]),
-      objectOrNull: z.object({ myString: z.string() }).nullable(),
-      passthrough: z.object({ myString: z.string() }).passthrough(),
-    });
-
-    const parsedSchema = parseDef(zodSchema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        requiredString: {
-          type: 'string',
-        },
-        optionalString: {
-          type: 'string',
-        },
-        literalString: {
-          type: 'string',
-          const: 'literalStringValue',
-        },
-        stringArray: {
-          type: 'array',
-          items: {
-            type: 'string',
-          },
-        },
-        stringEnum: {
-          type: 'string',
-          enum: ['stringEnumOptionA', 'stringEnumOptionB'],
-        },
-        tuple: {
-          type: 'array',
-          minItems: 3,
-          items: [
-            {
-              type: 'string',
-            },
-            {
-              type: 'number',
-            },
-            {
-              type: 'boolean',
-            },
-          ],
-          maxItems: 3,
-        },
-        record: {
-          type: 'object',
-          additionalProperties: {
-            type: 'boolean',
-          },
-        },
-        requiredNumber: {
-          type: 'number',
-        },
-        optionalNumber: {
-          type: 'number',
-        },
-        numberOrNull: {
-          type: ['number', 'null'],
-        },
-        numberUnion: {
-          type: 'number',
-          enum: [1, 2, 3],
-        },
-        mixedUnion: {
-          anyOf: [
-            {
-              type: 'string',
-              const: 'abc',
-            },
-            {
-              type: 'number',
-              const: 123,
-            },
-            {
-              type: 'object',
-              properties: {
-                nowItGetsAnnoying: {
-                  type: 'boolean',
-                  const: true,
-                },
-              },
-              required: ['nowItGetsAnnoying'],
-              additionalProperties: false,
-            },
-          ],
-        },
-        objectOrNull: {
-          anyOf: [
-            {
-              type: 'object',
-              properties: {
-                myString: {
-                  type: 'string',
-                },
-              },
-              required: ['myString'],
-              additionalProperties: false,
-            },
-            {
-              type: 'null',
-            },
-          ],
-        },
-        passthrough: {
-          type: 'object',
-          properties: {
-            myString: {
-              type: 'string',
-            },
-          },
-          required: ['myString'],
-          additionalProperties: true,
-        },
-      },
-      required: [
-        'requiredString',
-        'literalString',
-        'stringArray',
-        'stringEnum',
-        'tuple',
-        'record',
-        'requiredNumber',
-        'numberOrNull',
-        'numberUnion',
-        'mixedUnion',
-        'objectOrNull',
-        'passthrough',
-      ],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should handle a nullable string properly', () => {
-    const shorthand = z.string().nullable();
-    const union = z.union([z.string(), z.null()]);
-
-    expect(parseDef(shorthand._def, getRefs())).toStrictEqual({
-      type: ['string', 'null'],
-    } satisfies JSONSchema7);
-    expect(parseDef(union._def, getRefs())).toStrictEqual({
-      type: ['string', 'null'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use branded string', () => {
-    const schema = z.string().brand<'x'>();
-    const parsedSchema = parseDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use readonly', () => {
-    const parsedSchema = parseDef(z.object({}).readonly()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {},
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use catch', () => {
-    const parsedSchema = parseDef(z.number().catch(5)._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use pipeline', () => {
-    const schema = z.number().pipe(z.number().int());
-
-    expect(parseDef(schema._def, getRefs())).toStrictEqual({
-      allOf: [{ type: 'number' }, { type: 'integer' }],
-    } satisfies JSONSchema7);
-  });
-
-  it('should get undefined for function', () => {
-    const parsedSchema = parseDef(z.function()._def, getRefs());
-    expect(parsedSchema).toBeUndefined();
-  });
-
-  it('should get undefined for void', () => {
-    const parsedSchema = parseDef(z.void()._def, getRefs());
-    expect(parsedSchema).toBeUndefined();
-  });
-
-  it('nested lazy', () => {
-    const zodSchema = z.lazy(() => z.lazy(() => z.string()));
-    const parsed = parseDef(zodSchema._def, getRefs());
-
-    expect(parsed).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.ts
deleted file mode 100644
index b2f6b8d..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.ts
+++ /dev/null
@@ -1,109 +0,0 @@
-import { ZodTypeDef } from 'zod/v3';
-import { Refs, Seen } from './refs';
-import { ignoreOverride } from './options';
-import { JsonSchema7Type } from './parse-types';
-import { selectParser } from './select-parser';
-import { getRelativePath } from './get-relative-path';
-import { parseAnyDef } from './parsers/any';
-
-export function parseDef(
-  def: ZodTypeDef,
-  refs: Refs,
-  forceResolution = false, // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.
-): JsonSchema7Type | undefined {
-  const seenItem = refs.seen.get(def);
-
-  if (refs.override) {
-    const overrideResult = refs.override?.(
-      def,
-      refs,
-      seenItem,
-      forceResolution,
-    );
-
-    if (overrideResult !== ignoreOverride) {
-      return overrideResult;
-    }
-  }
-
-  if (seenItem && !forceResolution) {
-    const seenSchema = get$ref(seenItem, refs);
-
-    if (seenSchema !== undefined) {
-      return seenSchema;
-    }
-  }
-
-  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };
-
-  refs.seen.set(def, newItem);
-
-  const jsonSchemaOrGetter = selectParser(def, (def as any).typeName, refs);
-
-  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)
-  const jsonSchema =
-    typeof jsonSchemaOrGetter === 'function'
-      ? parseDef(jsonSchemaOrGetter(), refs)
-      : jsonSchemaOrGetter;
-
-  if (jsonSchema) {
-    addMeta(def, refs, jsonSchema);
-  }
-
-  if (refs.postProcess) {
-    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
-
-    newItem.jsonSchema = jsonSchema;
-
-    return postProcessResult;
-  }
-
-  newItem.jsonSchema = jsonSchema;
-
-  return jsonSchema;
-}
-
-const get$ref = (
-  item: Seen,
-  refs: Refs,
-):
-  | {
-      $ref: string;
-    }
-  | {}
-  | undefined => {
-  switch (refs.$refStrategy) {
-    case 'root':
-      return { $ref: item.path.join('/') };
-    case 'relative':
-      return { $ref: getRelativePath(refs.currentPath, item.path) };
-    case 'none':
-    case 'seen': {
-      if (
-        item.path.length < refs.currentPath.length &&
-        item.path.every((value, index) => refs.currentPath[index] === value)
-      ) {
-        console.warn(
-          `Recursive reference detected at ${refs.currentPath.join(
-            '/',
-          )}! Defaulting to any`,
-        );
-
-        return parseAnyDef();
-      }
-
-      return refs.$refStrategy === 'seen' ? parseAnyDef() : undefined;
-    }
-  }
-};
-
-const addMeta = (
-  def: ZodTypeDef,
-  refs: Refs,
-  jsonSchema: JsonSchema7Type,
-): JsonSchema7Type => {
-  if (def.description) {
-    jsonSchema.description = def.description;
-  }
-  return jsonSchema;
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-types.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-types.ts
deleted file mode 100644
index 2da338f..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-types.ts
+++ /dev/null
@@ -1,57 +0,0 @@
-import { JsonSchema7AnyType } from './parsers/any';
-import { JsonSchema7ArrayType } from './parsers/array';
-import { JsonSchema7BigintType } from './parsers/bigint';
-import { JsonSchema7BooleanType } from './parsers/boolean';
-import { JsonSchema7DateType } from './parsers/date';
-import { JsonSchema7EnumType } from './parsers/enum';
-import { JsonSchema7AllOfType } from './parsers/intersection';
-import { JsonSchema7LiteralType } from './parsers/literal';
-import { JsonSchema7MapType } from './parsers/map';
-import { JsonSchema7NativeEnumType } from './parsers/native-enum';
-import { JsonSchema7NeverType } from './parsers/never';
-import { JsonSchema7NullType } from './parsers/null';
-import { JsonSchema7NullableType } from './parsers/nullable';
-import { JsonSchema7NumberType } from './parsers/number';
-import { JsonSchema7ObjectType } from './parsers/object';
-import { JsonSchema7RecordType } from './parsers/record';
-import { JsonSchema7SetType } from './parsers/set';
-import { JsonSchema7StringType } from './parsers/string';
-import { JsonSchema7TupleType } from './parsers/tuple';
-import { JsonSchema7UndefinedType } from './parsers/undefined';
-import { JsonSchema7UnionType } from './parsers/union';
-import { JsonSchema7UnknownType } from './parsers/unknown';
-
-type JsonSchema7RefType = { $ref: string };
-type JsonSchema7Meta = {
-  title?: string;
-  default?: any;
-  description?: string;
-};
-
-export type JsonSchema7TypeUnion =
-  | JsonSchema7StringType
-  | JsonSchema7ArrayType
-  | JsonSchema7NumberType
-  | JsonSchema7BigintType
-  | JsonSchema7BooleanType
-  | JsonSchema7DateType
-  | JsonSchema7EnumType
-  | JsonSchema7LiteralType
-  | JsonSchema7NativeEnumType
-  | JsonSchema7NullType
-  | JsonSchema7NumberType
-  | JsonSchema7ObjectType
-  | JsonSchema7RecordType
-  | JsonSchema7TupleType
-  | JsonSchema7UnionType
-  | JsonSchema7UndefinedType
-  | JsonSchema7RefType
-  | JsonSchema7NeverType
-  | JsonSchema7MapType
-  | JsonSchema7AnyType
-  | JsonSchema7NullableType
-  | JsonSchema7AllOfType
-  | JsonSchema7UnknownType
-  | JsonSchema7SetType;
-
-export type JsonSchema7Type = JsonSchema7TypeUnion & JsonSchema7Meta;
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/any.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/any.ts
deleted file mode 100644
index 5e119ed..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/any.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-export type JsonSchema7AnyType = { $ref?: string };
-
-export function parseAnyDef(): JsonSchema7AnyType {
-  return {};
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.test.ts
deleted file mode 100644
index 6932b91..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.test.ts
+++ /dev/null
@@ -1,98 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import { parseArrayDef } from './array';
-import { getRefs } from '../refs';
-
-describe('array', () => {
-  it('should be possible to describe a simple array', () => {
-    const parsedSchema = parseArrayDef(z.array(z.string())._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      items: {
-        type: 'string',
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a simple array with any item', () => {
-    const parsedSchema = parseArrayDef(z.array(z.any())._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a string array with a minimum and maximum length', () => {
-    const parsedSchema = parseArrayDef(
-      z.array(z.string()).min(2).max(4)._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      items: {
-        type: 'string',
-      },
-      minItems: 2,
-      maxItems: 4,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a string array with an exact length', () => {
-    const parsedSchema = parseArrayDef(
-      z.array(z.string()).length(5)._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      items: {
-        type: 'string',
-      },
-      minItems: 5,
-      maxItems: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a string array with a minimum length of 1 by using nonempty', () => {
-    const parsedSchema = parseArrayDef(
-      z.array(z.any()).nonempty()._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      minItems: 1,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible do properly reference array items', () => {
-    const willHaveBeenSeen = z.object({ hello: z.string() });
-    const unionSchema = z.union([willHaveBeenSeen, willHaveBeenSeen]);
-    const arraySchema = z.array(unionSchema);
-    const jsonSchema = parseArrayDef(arraySchema._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      items: {
-        anyOf: [
-          {
-            additionalProperties: false,
-            properties: {
-              hello: {
-                type: 'string',
-              },
-            },
-            required: ['hello'],
-            type: 'object',
-          },
-          {
-            $ref: '#/items/anyOf/0',
-          },
-        ],
-      },
-      type: 'array',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.ts
deleted file mode 100644
index 940b105..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-import { ZodArrayDef, ZodFirstPartyTypeKind } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export type JsonSchema7ArrayType = {
-  type: 'array';
-  items?: JsonSchema7Type;
-  minItems?: number;
-  maxItems?: number;
-};
-
-export function parseArrayDef(def: ZodArrayDef, refs: Refs) {
-  const res: JsonSchema7ArrayType = {
-    type: 'array',
-  };
-  if (
-    def.type?._def &&
-    def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny
-  ) {
-    res.items = parseDef(def.type._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'items'],
-    });
-  }
-
-  if (def.minLength) {
-    res.minItems = def.minLength.value;
-  }
-  if (def.maxLength) {
-    res.maxItems = def.maxLength.value;
-  }
-  if (def.exactLength) {
-    res.minItems = def.exactLength.value;
-    res.maxItems = def.exactLength.value;
-  }
-  return res;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.test.ts
deleted file mode 100644
index 8884a86..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.test.ts
+++ /dev/null
@@ -1,51 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import { parseBigintDef } from './bigint';
-
-describe('bigint', () => {
-  it('should be possible to use bigint', () => {
-    const parsedSchema = parseBigintDef(z.bigint()._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'int64',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to define gt/lt', () => {
-    const parsedSchema = parseBigintDef(
-      z.bigint().gte(BigInt(10)).lte(BigInt(20))._def,
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'int64',
-      minimum: BigInt(10) as any, // json schema type does not support bigint
-      maximum: BigInt(20) as any, // json schema type does not support bigint
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to define gt/lt', () => {
-    const parsedSchema = parseBigintDef(
-      z.bigint().gt(BigInt(10)).lt(BigInt(20))._def,
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'int64',
-      exclusiveMinimum: BigInt(10) as any, // json schema type does not support bigint
-      exclusiveMaximum: BigInt(20) as any, // json schema type does not support bigint
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to define multipleOf', () => {
-    const parsedSchema = parseBigintDef(z.bigint().multipleOf(BigInt(5))._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'int64',
-      multipleOf: BigInt(5) as any, // json schema type does not support bigint
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts
deleted file mode 100644
index 1185a6f..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import { ZodBigIntDef } from 'zod/v3';
-
-export type JsonSchema7BigintType = {
-  type: 'integer';
-  format: 'int64';
-  minimum?: BigInt;
-  exclusiveMinimum?: BigInt;
-  maximum?: BigInt;
-  exclusiveMaximum?: BigInt;
-  multipleOf?: BigInt;
-};
-
-export function parseBigintDef(def: ZodBigIntDef): JsonSchema7BigintType {
-  const res: JsonSchema7BigintType = {
-    type: 'integer',
-    format: 'int64',
-  };
-
-  if (!def.checks) return res;
-
-  for (const check of def.checks) {
-    switch (check.kind) {
-      case 'min':
-        if (check.inclusive) {
-          res.minimum = check.value;
-        } else {
-          res.exclusiveMinimum = check.value;
-        }
-        break;
-      case 'max':
-        if (check.inclusive) {
-          res.maximum = check.value;
-        } else {
-          res.exclusiveMaximum = check.value;
-        }
-
-        break;
-      case 'multipleOf':
-        res.multipleOf = check.value;
-        break;
-    }
-  }
-  return res;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts
deleted file mode 100644
index b637634..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-export type JsonSchema7BooleanType = {
-  type: 'boolean';
-};
-
-export function parseBooleanDef(): JsonSchema7BooleanType {
-  return { type: 'boolean' };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.test.ts
deleted file mode 100644
index 120a9fa..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.test.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseBrandedDef } from './branded';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('branded', () => {
-  it('should be possible to use branded string', () => {
-    const schema = z.string().brand<'x'>();
-    const parsedSchema = parseBrandedDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.ts
deleted file mode 100644
index d388a2d..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { ZodBrandedDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { Refs } from '../refs';
-
-export function parseBrandedDef(_def: ZodBrandedDef<any>, refs: Refs) {
-  return parseDef(_def.type._def, refs);
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.test.ts
deleted file mode 100644
index c83925f..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.test.ts
+++ /dev/null
@@ -1,15 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseCatchDef } from './catch';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('catch', () => {
-  it('should be possible to use catch', () => {
-    const parsedSchema = parseCatchDef(z.number().catch(5)._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.ts
deleted file mode 100644
index b20308a..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { ZodCatchDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { Refs } from '../refs';
-
-export const parseCatchDef = (def: ZodCatchDef<any>, refs: Refs) => {
-  return parseDef(def.innerType._def, refs);
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.test.ts
deleted file mode 100644
index ef91ae1..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.test.ts
+++ /dev/null
@@ -1,97 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseDateDef } from './date';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('Date validations', it => {
-  it('should be possible to date as a string type', () => {
-    const zodDateSchema = z.date();
-    const parsedSchemaWithOption = parseDateDef(
-      zodDateSchema._def,
-      getRefs({ dateStrategy: 'string' }),
-    );
-    const parsedSchemaFromDefault = parseDateDef(zodDateSchema._def, getRefs());
-
-    const jsonSchema: JSONSchema7 = {
-      type: 'string',
-      format: 'date-time',
-    };
-
-    expect(parsedSchemaWithOption).toStrictEqual(jsonSchema);
-    expect(parsedSchemaFromDefault).toStrictEqual(jsonSchema);
-  });
-
-  it('should be possible to describe minimum date', () => {
-    const zodDateSchema = z
-      .date()
-      .min(new Date('1970-01-02'), { message: 'Too old' });
-    const parsedSchema = parseDateDef(
-      zodDateSchema._def,
-      getRefs({ dateStrategy: 'integer' }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'unix-time',
-      minimum: 86400000,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe maximum date', () => {
-    const zodDateSchema = z.date().max(new Date('1970-01-02'));
-    const parsedSchema = parseDateDef(
-      zodDateSchema._def,
-      getRefs({ dateStrategy: 'integer' }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'unix-time',
-      maximum: 86400000,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe both maximum and minimum date', () => {
-    const zodDateSchema = z
-      .date()
-      .min(new Date('1970-01-02'))
-      .max(new Date('1972-01-02'));
-    const parsedSchema = parseDateDef(
-      zodDateSchema._def,
-      getRefs({ dateStrategy: 'integer' }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-      format: 'unix-time',
-      minimum: 86400000,
-      maximum: 63158400000,
-    } satisfies JSONSchema7);
-  });
-
-  it('multiple choices of strategy should result in anyOf', () => {
-    const zodDateSchema = z.date();
-    const parsedSchema = parseDateDef(
-      zodDateSchema._def,
-      getRefs({ dateStrategy: ['format:date-time', 'format:date', 'integer'] }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      anyOf: [
-        {
-          type: 'string',
-          format: 'date-time',
-        },
-        {
-          type: 'string',
-          format: 'date',
-        },
-        {
-          type: 'integer',
-          format: 'unix-time',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.ts
deleted file mode 100644
index a468328..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.ts
+++ /dev/null
@@ -1,64 +0,0 @@
-import { ZodDateDef } from 'zod/v3';
-import { Refs } from '../refs';
-import { DateStrategy } from '../options';
-
-export type JsonSchema7DateType =
-  | {
-      type: 'integer' | 'string';
-      format: 'unix-time' | 'date-time' | 'date';
-      minimum?: number;
-      maximum?: number;
-    }
-  | {
-      anyOf: JsonSchema7DateType[];
-    };
-
-export function parseDateDef(
-  def: ZodDateDef,
-  refs: Refs,
-  overrideDateStrategy?: DateStrategy,
-): JsonSchema7DateType {
-  const strategy = overrideDateStrategy ?? refs.dateStrategy;
-
-  if (Array.isArray(strategy)) {
-    return {
-      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),
-    };
-  }
-
-  switch (strategy) {
-    case 'string':
-    case 'format:date-time':
-      return {
-        type: 'string',
-        format: 'date-time',
-      };
-    case 'format:date':
-      return {
-        type: 'string',
-        format: 'date',
-      };
-    case 'integer':
-      return integerDateParser(def);
-  }
-}
-
-const integerDateParser = (def: ZodDateDef) => {
-  const res: JsonSchema7DateType = {
-    type: 'integer',
-    format: 'unix-time',
-  };
-
-  for (const check of def.checks) {
-    switch (check.kind) {
-      case 'min':
-        res.minimum = check.value;
-        break;
-      case 'max':
-        res.maximum = check.value;
-        break;
-    }
-  }
-
-  return res;
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.test.ts
deleted file mode 100644
index 14a062c..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.test.ts
+++ /dev/null
@@ -1,54 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseDefaultDef } from './default';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('default', () => {
-  it('should be possible to use default on objects', () => {
-    const parsedSchema = parseDefaultDef(
-      z.object({ foo: z.boolean() }).default({ foo: true })._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: false,
-      required: ['foo'],
-      properties: {
-        foo: {
-          type: 'boolean',
-        },
-      },
-      default: {
-        foo: true,
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use default on primitives', () => {
-    const parsedSchema = parseDefaultDef(
-      z.string().default('default')._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      default: 'default',
-    } satisfies JSONSchema7);
-  });
-
-  it('default with transform', () => {
-    const stringWithDefault = z
-      .string()
-      .transform(val => val.toUpperCase())
-      .default('default');
-
-    const parsedSchema = parseDefaultDef(stringWithDefault._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      default: 'default',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.ts
deleted file mode 100644
index 26438e3..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.ts
+++ /dev/null
@@ -1,14 +0,0 @@
-import { ZodDefaultDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export function parseDefaultDef(
-  _def: ZodDefaultDef,
-  refs: Refs,
-): JsonSchema7Type & { default: any } {
-  return {
-    ...parseDef(_def.innerType._def, refs),
-    default: _def.defaultValue(),
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.test.ts
deleted file mode 100644
index bba87da..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.test.ts
+++ /dev/null
@@ -1,41 +0,0 @@
-import { describe, it, expect, test } from 'vitest';
-import { z } from 'zod/v3';
-import { parseEffectsDef } from './effects';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('effects', () => {
-  it('should be possible to use refine', () => {
-    const parsedSchema = parseEffectsDef(
-      z.number().refine(x => x + 1)._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-    } satisfies JSONSchema7);
-  });
-
-  it('should default to the input type', () => {
-    const schema = z.string().transform(arg => parseInt(arg));
-
-    const jsonSchema = parseEffectsDef(schema._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-
-  test("should return object based on 'any' strategy", () => {
-    const schema = z.string().transform(arg => parseInt(arg));
-
-    const jsonSchema = parseEffectsDef(
-      schema._def,
-      getRefs({
-        effectStrategy: 'any',
-      }),
-    );
-
-    expect(jsonSchema).toStrictEqual({} satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.ts
deleted file mode 100644
index 6f659c0..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.ts
+++ /dev/null
@@ -1,14 +0,0 @@
-import { ZodEffectsDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { parseAnyDef } from './any';
-
-export function parseEffectsDef(
-  _def: ZodEffectsDef,
-  refs: Refs,
-): JsonSchema7Type | undefined {
-  return refs.effectStrategy === 'input'
-    ? parseDef(_def.schema._def, refs)
-    : parseAnyDef();
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/enum.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/enum.ts
deleted file mode 100644
index 9a6e023..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/enum.ts
+++ /dev/null
@@ -1,13 +0,0 @@
-import { ZodEnumDef } from 'zod/v3';
-
-export type JsonSchema7EnumType = {
-  type: 'string';
-  enum: string[];
-};
-
-export function parseEnumDef(def: ZodEnumDef): JsonSchema7EnumType {
-  return {
-    type: 'string',
-    enum: Array.from(def.values),
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.test.ts
deleted file mode 100644
index fd2fbf5..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.test.ts
+++ /dev/null
@@ -1,92 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseIntersectionDef } from './intersection';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('intersection', () => {
-  it('should be possible to use intersections', () => {
-    const intersection = z.intersection(z.string().min(1), z.string().max(3));
-
-    const jsonSchema = parseIntersectionDef(intersection._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      allOf: [
-        {
-          type: 'string',
-          minLength: 1,
-        },
-        {
-          type: 'string',
-          maxLength: 3,
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to deref intersections', () => {
-    const schema = z.string();
-    const intersection = z.intersection(schema, schema);
-    const jsonSchema = parseIntersectionDef(intersection._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      allOf: [
-        {
-          type: 'string',
-        },
-        {
-          $ref: '#/allOf/0',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should return `unevaluatedProperties` only if all of the multiple sub-schemas have additionalProperties set to false', () => {
-    const schema1 = z.object({
-      foo: z.string(),
-    });
-    const schema2 = z.object({
-      bar: z.string(),
-    });
-    const schema3 = z
-      .object({
-        baz: z.string(),
-      })
-      .passthrough();
-    const intersection = schema1.and(schema2).and(schema3);
-    const jsonSchema = parseIntersectionDef(intersection._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      allOf: [
-        {
-          properties: {
-            foo: {
-              type: 'string',
-            },
-          },
-          required: ['foo'],
-          type: 'object',
-        },
-        {
-          properties: {
-            bar: {
-              type: 'string',
-            },
-          },
-          required: ['bar'],
-          type: 'object',
-        },
-        {
-          additionalProperties: true,
-          properties: {
-            baz: {
-              type: 'string',
-            },
-          },
-          required: ['baz'],
-          type: 'object',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts
deleted file mode 100644
index e2916d2..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts
+++ /dev/null
@@ -1,52 +0,0 @@
-import { ZodIntersectionDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { JsonSchema7StringType } from './string';
-
-export type JsonSchema7AllOfType = {
-  allOf: JsonSchema7Type[];
-  unevaluatedProperties?: boolean;
-};
-
-const isJsonSchema7AllOfType = (
-  type: JsonSchema7Type | JsonSchema7StringType,
-): type is JsonSchema7AllOfType => {
-  if ('type' in type && type.type === 'string') return false;
-  return 'allOf' in type;
-};
-
-export function parseIntersectionDef(
-  def: ZodIntersectionDef,
-  refs: Refs,
-): JsonSchema7AllOfType | JsonSchema7Type | undefined {
-  const allOf = [
-    parseDef(def.left._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'allOf', '0'],
-    }),
-    parseDef(def.right._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'allOf', '1'],
-    }),
-  ].filter((x): x is JsonSchema7Type => !!x);
-
-  const mergedAllOf: JsonSchema7Type[] = [];
-  // If either of the schemas is an allOf, merge them into a single allOf
-  allOf.forEach(schema => {
-    if (isJsonSchema7AllOfType(schema)) {
-      mergedAllOf.push(...schema.allOf);
-    } else {
-      let nestedSchema: JsonSchema7Type = schema;
-      if (
-        'additionalProperties' in schema &&
-        schema.additionalProperties === false
-      ) {
-        const { additionalProperties, ...rest } = schema;
-        nestedSchema = rest;
-      }
-      mergedAllOf.push(nestedSchema);
-    }
-  });
-  return mergedAllOf.length ? { allOf: mergedAllOf } : undefined;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/literal.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/literal.ts
deleted file mode 100644
index bb1c384..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/literal.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-import { ZodLiteralDef } from 'zod/v3';
-
-export type JsonSchema7LiteralType =
-  | {
-      type: 'string' | 'number' | 'integer' | 'boolean';
-      const: string | number | boolean;
-    }
-  | {
-      type: 'object' | 'array';
-    };
-
-export function parseLiteralDef(def: ZodLiteralDef): JsonSchema7LiteralType {
-  const parsedType = typeof def.value;
-  if (
-    parsedType !== 'bigint' &&
-    parsedType !== 'number' &&
-    parsedType !== 'boolean' &&
-    parsedType !== 'string'
-  ) {
-    return {
-      type: Array.isArray(def.value) ? 'array' : 'object',
-    };
-  }
-
-  return {
-    type: parsedType === 'bigint' ? 'integer' : parsedType,
-    const: def.value,
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.test.ts
deleted file mode 100644
index 9adf502..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.test.ts
+++ /dev/null
@@ -1,48 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseMapDef } from './map';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('map', () => {
-  it('should be possible to use Map', () => {
-    const mapSchema = z.map(z.string(), z.number());
-
-    const parsedSchema = parseMapDef(mapSchema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      maxItems: 125,
-      items: {
-        type: 'array',
-        items: [
-          {
-            type: 'string',
-          },
-          {
-            type: 'number',
-          },
-        ],
-        minItems: 2,
-        maxItems: 2,
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use additionalProperties-pattern (record)', () => {
-    expect(
-      parseMapDef(
-        z.map(z.string().min(1), z.number())._def,
-        getRefs({ mapStrategy: 'record' }),
-      ),
-    ).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'number',
-      },
-      propertyNames: {
-        minLength: 1,
-      },
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.ts
deleted file mode 100644
index b719f61..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-import { ZodMapDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { parseAnyDef } from './any';
-import { JsonSchema7RecordType, parseRecordDef } from './record';
-
-export type JsonSchema7MapType = {
-  type: 'array';
-  maxItems: 125;
-  items: {
-    type: 'array';
-    items: [JsonSchema7Type, JsonSchema7Type];
-    minItems: 2;
-    maxItems: 2;
-  };
-};
-
-export function parseMapDef(
-  def: ZodMapDef,
-  refs: Refs,
-): JsonSchema7MapType | JsonSchema7RecordType {
-  if (refs.mapStrategy === 'record') {
-    return parseRecordDef(def, refs);
-  }
-
-  const keys =
-    parseDef(def.keyType._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'items', 'items', '0'],
-    }) || parseAnyDef();
-  const values =
-    parseDef(def.valueType._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'items', 'items', '1'],
-    }) || parseAnyDef();
-  return {
-    type: 'array',
-    maxItems: 125,
-    items: {
-      type: 'array',
-      items: [keys, values],
-      minItems: 2,
-      maxItems: 2,
-    },
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.test.ts
deleted file mode 100644
index 299d18e..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.test.ts
+++ /dev/null
@@ -1,102 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseNativeEnumDef } from './native-enum';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('native enum', () => {
-  it('should be possible to convert a basic native number enum', () => {
-    enum MyEnum {
-      val1,
-      val2,
-      val3,
-    }
-
-    const parsedSchema = parseNativeEnumDef(z.nativeEnum(MyEnum)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      enum: [0, 1, 2],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to convert a native string enum', () => {
-    enum MyEnum {
-      val1 = 'a',
-      val2 = 'b',
-      val3 = 'c',
-    }
-
-    const parsedSchema = parseNativeEnumDef(z.nativeEnum(MyEnum)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      enum: ['a', 'b', 'c'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to convert a mixed value native enum', () => {
-    enum MyEnum {
-      val1 = 'a',
-      val2 = 1,
-      val3 = 'c',
-    }
-
-    const parsedSchema = parseNativeEnumDef(z.nativeEnum(MyEnum)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: ['string', 'number'],
-      enum: ['a', 1, 'c'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to convert a native const assertion object', () => {
-    const MyConstAssertionObject = {
-      val1: 0,
-      val2: 1,
-      val3: 2,
-    } as const;
-
-    const parsedSchema = parseNativeEnumDef(
-      z.nativeEnum(MyConstAssertionObject)._def,
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      enum: [0, 1, 2],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to convert a native const assertion string object', () => {
-    const MyConstAssertionObject = {
-      val1: 'a',
-      val2: 'b',
-      val3: 'c',
-    } as const;
-
-    const parsedSchema = parseNativeEnumDef(
-      z.nativeEnum(MyConstAssertionObject)._def,
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      enum: ['a', 'b', 'c'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to convert a mixed value native const assertion string object', () => {
-    const MyConstAssertionObject = {
-      val1: 'a',
-      val2: 1,
-      val3: 'c',
-    } as const;
-
-    const parsedSchema = parseNativeEnumDef(
-      z.nativeEnum(MyConstAssertionObject)._def,
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: ['string', 'number'],
-      enum: ['a', 1, 'c'],
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts
deleted file mode 100644
index cff1925..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-import { ZodNativeEnumDef } from 'zod/v3';
-
-export type JsonSchema7NativeEnumType = {
-  type: 'string' | 'number' | ['string', 'number'];
-  enum: (string | number)[];
-};
-
-export function parseNativeEnumDef(
-  def: ZodNativeEnumDef,
-): JsonSchema7NativeEnumType {
-  const object = def.values;
-  const actualKeys = Object.keys(def.values).filter((key: string) => {
-    return typeof object[object[key]] !== 'number';
-  });
-
-  const actualValues = actualKeys.map((key: string) => object[key]);
-
-  const parsedTypes = Array.from(
-    new Set(actualValues.map((values: string | number) => typeof values)),
-  );
-
-  return {
-    type:
-      parsedTypes.length === 1
-        ? parsedTypes[0] === 'string'
-          ? 'string'
-          : 'number'
-        : ['string', 'number'],
-    enum: actualValues,
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/never.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/never.ts
deleted file mode 100644
index 7957830..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/never.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-import { JsonSchema7AnyType, parseAnyDef } from './any';
-
-export type JsonSchema7NeverType = {
-  not: JsonSchema7AnyType;
-};
-
-export function parseNeverDef(): JsonSchema7NeverType | undefined {
-  return { not: parseAnyDef() };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/null.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/null.ts
deleted file mode 100644
index a1335a3..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/null.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-export type JsonSchema7NullType = {
-  type: 'null';
-};
-
-export function parseNullDef(): JsonSchema7NullType {
-  return {
-    type: 'null',
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.test.ts
deleted file mode 100644
index 6aeabb5..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.test.ts
+++ /dev/null
@@ -1,67 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseObjectDef } from './object';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('nullable', () => {
-  it('should be possible to properly reference nested nullable primitives', () => {
-    const nullablePrimitive = z.string().nullable();
-
-    const schema = z.object({
-      one: nullablePrimitive,
-      two: nullablePrimitive,
-    });
-
-    const jsonSchema: any = parseObjectDef(schema._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      additionalProperties: false,
-      type: 'object',
-      properties: {
-        one: { type: ['string', 'null'] },
-        two: { $ref: '#/properties/one' },
-      },
-      required: ['one', 'two'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to properly reference nested nullable primitives', () => {
-    const three = z.string();
-
-    const nullableObject = z
-      .object({
-        three,
-      })
-      .nullable();
-
-    const schema = z.object({
-      one: nullableObject,
-      two: nullableObject,
-      three,
-    });
-
-    const jsonSchema: any = parseObjectDef(schema._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        one: {
-          anyOf: [
-            {
-              type: 'object',
-              additionalProperties: false,
-              required: ['three'],
-              properties: { three: { type: 'string' } },
-            },
-            { type: 'null' },
-          ],
-        },
-        two: { $ref: '#/properties/one' },
-        three: { $ref: '#/properties/one/anyOf/0/properties/three' },
-      },
-      required: ['one', 'two', 'three'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts
deleted file mode 100644
index 8e06438..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { ZodNullableDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { JsonSchema7NullType } from './null';
-import { primitiveMappings } from './union';
-
-export type JsonSchema7NullableType =
-  | {
-      anyOf: [JsonSchema7Type, JsonSchema7NullType];
-    }
-  | {
-      type: [string, 'null'];
-    };
-
-export function parseNullableDef(
-  def: ZodNullableDef,
-  refs: Refs,
-): JsonSchema7NullableType | undefined {
-  if (
-    ['ZodString', 'ZodNumber', 'ZodBigInt', 'ZodBoolean', 'ZodNull'].includes(
-      def.innerType._def.typeName,
-    ) &&
-    (!def.innerType._def.checks || !def.innerType._def.checks.length)
-  ) {
-    return {
-      type: [
-        primitiveMappings[
-          def.innerType._def.typeName as keyof typeof primitiveMappings
-        ],
-        'null',
-      ],
-    };
-  }
-
-  const base = parseDef(def.innerType._def, {
-    ...refs,
-    currentPath: [...refs.currentPath, 'anyOf', '0'],
-  });
-
-  return base && { anyOf: [base, { type: 'null' }] };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.test.ts
deleted file mode 100644
index 233b0bd..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.test.ts
+++ /dev/null
@@ -1,65 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import { parseNumberDef } from './number';
-
-describe('number', () => {
-  it('should be possible to describe minimum number', () => {
-    const parsedSchema = parseNumberDef(z.number().min(5)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      minimum: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe maximum number', () => {
-    const parsedSchema = parseNumberDef(z.number().max(5)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      maximum: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe both minimum and maximum number', () => {
-    const parsedSchema = parseNumberDef(z.number().min(5).max(5)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      minimum: 5,
-      maximum: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe an integer', () => {
-    const parsedSchema = parseNumberDef(z.number().int()._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'integer',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe multiples of n', () => {
-    const parsedSchema = parseNumberDef(z.number().multipleOf(2)._def);
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      multipleOf: 2,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe positive, negative, nonpositive and nonnegative numbers', () => {
-    const parsedSchema = parseNumberDef(
-      z.number().positive().negative().nonpositive().nonnegative()._def,
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'number',
-      minimum: 0,
-      maximum: 0,
-      exclusiveMaximum: 0,
-      exclusiveMinimum: 0,
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.ts
deleted file mode 100644
index 318ee41..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import { ZodNumberDef } from 'zod/v3';
-
-export type JsonSchema7NumberType = {
-  type: 'number' | 'integer';
-  minimum?: number;
-  exclusiveMinimum?: number;
-  maximum?: number;
-  exclusiveMaximum?: number;
-  multipleOf?: number;
-};
-
-export function parseNumberDef(def: ZodNumberDef): JsonSchema7NumberType {
-  const res: JsonSchema7NumberType = {
-    type: 'number',
-  };
-
-  if (!def.checks) return res;
-
-  for (const check of def.checks) {
-    switch (check.kind) {
-      case 'int':
-        res.type = 'integer';
-        break;
-      case 'min':
-        if (check.inclusive) {
-          res.minimum = check.value;
-        } else {
-          res.exclusiveMinimum = check.value;
-        }
-        break;
-      case 'max':
-        if (check.inclusive) {
-          res.maximum = check.value;
-        } else {
-          res.exclusiveMaximum = check.value;
-        }
-        break;
-      case 'multipleOf':
-        res.multipleOf = check.value;
-        break;
-    }
-  }
-  return res;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.test.ts
deleted file mode 100644
index 0d31947..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.test.ts
+++ /dev/null
@@ -1,149 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseObjectDef } from './object';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('object', () => {
-  it('should be possible to describe catchAll schema', () => {
-    const schema = z
-      .object({ normalProperty: z.string() })
-      .catchall(z.boolean());
-
-    const parsedSchema = parseObjectDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        normalProperty: { type: 'string' },
-      },
-      required: ['normalProperty'],
-      additionalProperties: {
-        type: 'boolean',
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use selective partial', () => {
-    const schema = z
-      .object({ foo: z.boolean(), bar: z.number() })
-      .partial({ foo: true });
-
-    const parsedSchema = parseObjectDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        foo: { type: 'boolean' },
-        bar: { type: 'number' },
-      },
-      required: ['bar'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should allow additional properties unless strict when removeAdditionalStrategy is strict', () => {
-    const schema = z.object({ foo: z.boolean(), bar: z.number() });
-
-    const parsedSchema = parseObjectDef(
-      schema._def,
-      getRefs({ removeAdditionalStrategy: 'strict' }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        foo: { type: 'boolean' },
-        bar: { type: 'number' },
-      },
-      required: ['foo', 'bar'],
-      additionalProperties: true,
-    } satisfies JSONSchema7);
-
-    const strictSchema = z
-      .object({ foo: z.boolean(), bar: z.number() })
-      .strict();
-
-    const parsedStrictSchema = parseObjectDef(
-      strictSchema._def,
-      getRefs({ removeAdditionalStrategy: 'strict' }),
-    );
-
-    expect(parsedStrictSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        foo: { type: 'boolean' },
-        bar: { type: 'number' },
-      },
-      required: ['foo', 'bar'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should allow additional properties with catchall when removeAdditionalStrategy is strict', () => {
-    const schema = z
-      .object({ foo: z.boolean(), bar: z.number() })
-      .catchall(z.boolean());
-
-    const parsedSchema = parseObjectDef(
-      schema._def,
-      getRefs({ removeAdditionalStrategy: 'strict' }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        foo: { type: 'boolean' },
-        bar: { type: 'number' },
-      },
-      required: ['foo', 'bar'],
-      additionalProperties: {
-        type: 'boolean',
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to not set additionalProperties at all when allowed', () => {
-    const schema = z
-      .object({ foo: z.boolean(), bar: z.number() })
-      .passthrough();
-
-    const parsedSchema = parseObjectDef(
-      schema._def,
-      getRefs({
-        removeAdditionalStrategy: 'passthrough',
-        allowedAdditionalProperties: undefined,
-      }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        foo: { type: 'boolean' },
-        bar: { type: 'number' },
-      },
-      required: ['foo', 'bar'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to not set additionalProperties at all when rejected', () => {
-    const schema = z.object({ foo: z.boolean(), bar: z.number() }).strict();
-
-    const parsedSchema = parseObjectDef(
-      schema._def,
-      getRefs({
-        removeAdditionalStrategy: 'passthrough',
-        rejectedAdditionalProperties: undefined,
-      }),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        foo: { type: 'boolean' },
-        bar: { type: 'number' },
-      },
-      required: ['foo', 'bar'],
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.ts
deleted file mode 100644
index 44ef33a..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.ts
+++ /dev/null
@@ -1,88 +0,0 @@
-import { ZodObjectDef, ZodTypeAny } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export type JsonSchema7ObjectType = {
-  type: 'object';
-  properties: Record<string, JsonSchema7Type>;
-  additionalProperties?: boolean | JsonSchema7Type;
-  required?: string[];
-};
-
-export function parseObjectDef(def: ZodObjectDef, refs: Refs) {
-  const result: JsonSchema7ObjectType = {
-    type: 'object',
-    properties: {},
-  };
-
-  const required: string[] = [];
-
-  const shape = def.shape();
-
-  for (const propName in shape) {
-    let propDef = shape[propName];
-
-    if (propDef === undefined || propDef._def === undefined) {
-      continue;
-    }
-
-    const propOptional = safeIsOptional(propDef);
-
-    const parsedDef = parseDef(propDef._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'properties', propName],
-      propertyPath: [...refs.currentPath, 'properties', propName],
-    });
-
-    if (parsedDef === undefined) {
-      continue;
-    }
-
-    result.properties[propName] = parsedDef;
-
-    if (!propOptional) {
-      required.push(propName);
-    }
-  }
-
-  if (required.length) {
-    result.required = required;
-  }
-
-  const additionalProperties = decideAdditionalProperties(def, refs);
-
-  if (additionalProperties !== undefined) {
-    result.additionalProperties = additionalProperties;
-  }
-
-  return result;
-}
-
-function decideAdditionalProperties(def: ZodObjectDef, refs: Refs) {
-  if (def.catchall._def.typeName !== 'ZodNever') {
-    return parseDef(def.catchall._def, {
-      ...refs,
-      currentPath: [...refs.currentPath, 'additionalProperties'],
-    });
-  }
-
-  switch (def.unknownKeys) {
-    case 'passthrough':
-      return refs.allowedAdditionalProperties;
-    case 'strict':
-      return refs.rejectedAdditionalProperties;
-    case 'strip':
-      return refs.removeAdditionalStrategy === 'strict'
-        ? refs.allowedAdditionalProperties
-        : refs.rejectedAdditionalProperties;
-  }
-}
-
-function safeIsOptional(schema: ZodTypeAny): boolean {
-  try {
-    return schema.isOptional();
-  } catch {
-    return true;
-  }
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.test.ts
deleted file mode 100644
index e8f4258..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.test.ts
+++ /dev/null
@@ -1,147 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('Standalone optionals', () => {
-  it('should work as unions with undefined', () => {
-    const parsedSchema = parseDef(z.string().optional()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      anyOf: [
-        {
-          not: {},
-        },
-        {
-          type: 'string',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should work as unions with void', () => {
-    const parsedSchema = parseDef(z.void().optional()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({} satisfies JSONSchema7);
-  });
-
-  it('should not affect object properties', () => {
-    const parsedSchema = parseDef(
-      z.object({ myProperty: z.string().optional() })._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        myProperty: {
-          type: 'string',
-        },
-      },
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with nested properties', () => {
-    const parsedSchema = parseDef(
-      z.object({ myProperty: z.string().optional().array() })._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        myProperty: {
-          type: 'array',
-          items: {
-            anyOf: [{ not: {} }, { type: 'string' }],
-          },
-        },
-      },
-      required: ['myProperty'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with nested properties as object properties', () => {
-    const parsedSchema = parseDef(
-      z.object({
-        myProperty: z.object({ myInnerProperty: z.string().optional() }),
-      })._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        myProperty: {
-          type: 'object',
-          properties: {
-            myInnerProperty: {
-              type: 'string',
-            },
-          },
-          additionalProperties: false,
-        },
-      },
-      required: ['myProperty'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with nested properties with nested object property parents', () => {
-    const parsedSchema = parseDef(
-      z.object({
-        myProperty: z.object({
-          myInnerProperty: z.string().optional().array(),
-        }),
-      })._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {
-        myProperty: {
-          type: 'object',
-          properties: {
-            myInnerProperty: {
-              type: 'array',
-              items: {
-                anyOf: [
-                  { not: {} },
-                  {
-                    type: 'string',
-                  },
-                ],
-              },
-            },
-          },
-          required: ['myInnerProperty'],
-          additionalProperties: false,
-        },
-      },
-      required: ['myProperty'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with ref pathing', () => {
-    const recurring = z.string();
-
-    const schema = z.tuple([recurring.optional(), recurring]);
-
-    const parsedSchema = parseDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      minItems: 2,
-      maxItems: 2,
-      items: [
-        { anyOf: [{ not: {} }, { type: 'string' }] },
-        { $ref: '#/items/0/anyOf/1' },
-      ],
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.ts
deleted file mode 100644
index 0ff9406..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { ZodOptionalDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { parseAnyDef } from './any';
-
-export const parseOptionalDef = (
-  def: ZodOptionalDef,
-  refs: Refs,
-): JsonSchema7Type | undefined => {
-  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
-    return parseDef(def.innerType._def, refs);
-  }
-
-  const innerSchema = parseDef(def.innerType._def, {
-    ...refs,
-    currentPath: [...refs.currentPath, 'anyOf', '1'],
-  });
-
-  return innerSchema
-    ? { anyOf: [{ not: parseAnyDef() }, innerSchema] }
-    : parseAnyDef();
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipe.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipe.test.ts
deleted file mode 100644
index 51fe440..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipe.test.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parsePipelineDef } from './pipeline';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('pipe', () => {
-  it('Should create an allOf schema with all its inner schemas represented', () => {
-    const schema = z.number().pipe(z.number().int());
-
-    expect(parsePipelineDef(schema._def, getRefs())).toStrictEqual({
-      allOf: [{ type: 'number' }, { type: 'integer' }],
-    } satisfies JSONSchema7);
-  });
-
-  it('Should parse the input schema if that strategy is selected', () => {
-    const schema = z.number().pipe(z.number().int());
-
-    expect(
-      parsePipelineDef(schema._def, getRefs({ pipeStrategy: 'input' })),
-    ).toStrictEqual({
-      type: 'number',
-    } satisfies JSONSchema7);
-  });
-
-  it('Should parse the output schema (last schema in pipe) if that strategy is selected', () => {
-    const schema = z.string().pipe(z.date()).pipe(z.number().int());
-
-    expect(
-      parsePipelineDef(schema._def, getRefs({ pipeStrategy: 'output' })),
-    ).toStrictEqual({
-      type: 'integer',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts
deleted file mode 100644
index 73bb896..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-import { ZodPipelineDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { JsonSchema7AllOfType } from './intersection';
-
-export const parsePipelineDef = (
-  def: ZodPipelineDef<any, any>,
-  refs: Refs,
-): JsonSchema7AllOfType | JsonSchema7Type | undefined => {
-  if (refs.pipeStrategy === 'input') {
-    return parseDef(def.in._def, refs);
-  } else if (refs.pipeStrategy === 'output') {
-    return parseDef(def.out._def, refs);
-  }
-
-  const a = parseDef(def.in._def, {
-    ...refs,
-    currentPath: [...refs.currentPath, 'allOf', '0'],
-  });
-  const b = parseDef(def.out._def, {
-    ...refs,
-    currentPath: [...refs.currentPath, 'allOf', a ? '1' : '0'],
-  });
-
-  return {
-    allOf: [a, b].filter((x): x is JsonSchema7Type => x !== undefined),
-  };
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.test.ts
deleted file mode 100644
index c580773..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.test.ts
+++ /dev/null
@@ -1,15 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parsePromiseDef } from './promise';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('promise', () => {
-  it('should be possible to use promise', () => {
-    const parsedSchema = parsePromiseDef(z.promise(z.string())._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.ts
deleted file mode 100644
index 35d43d8..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-import { ZodPromiseDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export function parsePromiseDef(
-  def: ZodPromiseDef,
-  refs: Refs,
-): JsonSchema7Type | undefined {
-  return parseDef(def.type._def, refs);
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.test.ts
deleted file mode 100644
index 12c2a9a..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.test.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseReadonlyDef } from './readonly';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('readonly', () => {
-  it('should be possible to use readonly', () => {
-    const parsedSchema = parseReadonlyDef(
-      z.object({}).readonly()._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      properties: {},
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts
deleted file mode 100644
index 048b6fc..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { ZodReadonlyDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { Refs } from '../refs';
-
-export const parseReadonlyDef = (def: ZodReadonlyDef<any>, refs: Refs) => {
-  return parseDef(def.innerType._def, refs);
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.test.ts
deleted file mode 100644
index 31b5407..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.test.ts
+++ /dev/null
@@ -1,108 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseRecordDef } from './record';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('record', () => {
-  it('should be possible to describe a simple record', () => {
-    const schema = z.record(z.number());
-
-    const parsedSchema = parseRecordDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'number',
-      },
-    } satisfies JSONSchema7);
-  });
-  it('should be possible to describe a simple record with a branded key', () => {
-    const schema = z.record(z.string().brand('MyBrand'), z.number());
-
-    const parsedSchema = parseRecordDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'number',
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a complex record with checks', () => {
-    const schema = z.record(
-      z.object({ foo: z.number().min(2) }).catchall(z.string().cuid()),
-    );
-
-    const parsedSchema = parseRecordDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'object',
-        properties: {
-          foo: {
-            type: 'number',
-            minimum: 2,
-          },
-        },
-        required: ['foo'],
-        additionalProperties: {
-          type: 'string',
-          pattern: '^[cC][^\\s-]{8,}$',
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a key schema', () => {
-    const schema = z.record(z.string().uuid(), z.number());
-
-    const parsedSchema = parseRecordDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'number',
-      },
-      propertyNames: {
-        format: 'uuid',
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a branded key schema', () => {
-    const schema = z.record(
-      z.string().regex(/.+/).brand('MyBrandedThingo'),
-      z.number(),
-    );
-
-    const parsedSchema = parseRecordDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'number',
-      },
-      propertyNames: {
-        pattern: '.+',
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a key with an enum', () => {
-    const schema = z.record(z.enum(['foo', 'bar']), z.number());
-    const parsedSchema = parseRecordDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'object',
-      additionalProperties: {
-        type: 'number',
-      },
-      propertyNames: {
-        enum: ['foo', 'bar'],
-      },
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.ts
deleted file mode 100644
index 03c76c0..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import {
-  ZodFirstPartyTypeKind,
-  ZodMapDef,
-  ZodRecordDef,
-  ZodTypeAny,
-} from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-import { parseBrandedDef } from './branded';
-import { JsonSchema7EnumType } from './enum';
-import { JsonSchema7StringType, parseStringDef } from './string';
-
-type JsonSchema7RecordPropertyNamesType =
-  | Omit<JsonSchema7StringType, 'type'>
-  | Omit<JsonSchema7EnumType, 'type'>;
-
-export type JsonSchema7RecordType = {
-  type: 'object';
-  additionalProperties?: JsonSchema7Type | true;
-  propertyNames?: JsonSchema7RecordPropertyNamesType;
-};
-
-export function parseRecordDef(
-  def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef,
-  refs: Refs,
-): JsonSchema7RecordType {
-  const schema: JsonSchema7RecordType = {
-    type: 'object',
-    additionalProperties:
-      parseDef(def.valueType._def, {
-        ...refs,
-        currentPath: [...refs.currentPath, 'additionalProperties'],
-      }) ?? refs.allowedAdditionalProperties,
-  };
-
-  if (
-    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&
-    def.keyType._def.checks?.length
-  ) {
-    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
-
-    return {
-      ...schema,
-      propertyNames: keyType,
-    };
-  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
-    return {
-      ...schema,
-      propertyNames: {
-        enum: def.keyType._def.values,
-      },
-    };
-  } else if (
-    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&
-    def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&
-    def.keyType._def.type._def.checks?.length
-  ) {
-    const { type, ...keyType } = parseBrandedDef(
-      def.keyType._def,
-      refs,
-    ) as JsonSchema7StringType;
-
-    return {
-      ...schema,
-      propertyNames: keyType,
-    };
-  }
-
-  return schema;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.test.ts
deleted file mode 100644
index 5ecd390..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.test.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import { getRefs } from '../refs';
-import { parseSetDef } from './set';
-
-describe('set', () => {
-  it('should map set', () => {
-    const zodSchema = z.set(z.any()).min(5).max(10);
-    const jsonParsedSchema = parseSetDef(zodSchema._def, getRefs());
-
-    expect(jsonParsedSchema).toStrictEqual({
-      type: 'array',
-      minItems: 5,
-      maxItems: 10,
-      uniqueItems: true,
-      items: {},
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.ts
deleted file mode 100644
index a81f4b4..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-import { ZodSetDef } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export type JsonSchema7SetType = {
-  type: 'array';
-  uniqueItems: true;
-  items?: JsonSchema7Type;
-  minItems?: number;
-  maxItems?: number;
-};
-
-export function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType {
-  const items = parseDef(def.valueType._def, {
-    ...refs,
-    currentPath: [...refs.currentPath, 'items'],
-  });
-
-  const schema: JsonSchema7SetType = {
-    type: 'array',
-    uniqueItems: true,
-    items,
-  };
-
-  if (def.minSize) {
-    schema.minItems = def.minSize.value;
-  }
-
-  if (def.maxSize) {
-    schema.maxItems = def.maxSize.value;
-  }
-
-  return schema;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.test.ts
deleted file mode 100644
index 189e241..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.test.ts
+++ /dev/null
@@ -1,438 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import { getRefs } from '../refs';
-import { parseStringDef, zodPatterns } from './string';
-
-describe('string', () => {
-  it('should be possible to describe minimum length of a string', () => {
-    const parsedSchema = parseStringDef(z.string().min(5)._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      minLength: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe maximum length of a string', () => {
-    const parsedSchema = parseStringDef(z.string().max(5)._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      maxLength: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe both minimum and maximum length of a string', () => {
-    const parsedSchema = parseStringDef(
-      z.string().min(5).max(5)._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      minLength: 5,
-      maxLength: 5,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use email constraint', () => {
-    const parsedSchema = parseStringDef(z.string().email()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'email',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use uuid constraint', () => {
-    const parsedSchema = parseStringDef(z.string().uuid()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'uuid',
-    } satisfies JSONSchema7);
-  });
-  it('should be possible to use url constraint', () => {
-    const parsedSchema = parseStringDef(z.string().url()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'uri',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use regex constraint', () => {
-    const parsedSchema = parseStringDef(
-      z.string().regex(/[A-C]/)._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      pattern: '[A-C]',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use CUID constraint', () => {
-    const parsedSchema = parseStringDef(z.string().cuid()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      pattern: '^[cC][^\\s-]{8,}$',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use Cuid2 constraint', () => {
-    const parsedSchema = parseStringDef(z.string().cuid2()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      pattern: '^[0-9a-z]+$',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use datetime constraint', () => {
-    const parsedSchema = parseStringDef(z.string().datetime()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'date-time',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use date constraint', () => {
-    const parsedSchema = parseStringDef(z.string().date()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'date',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use time constraint', () => {
-    const parsedSchema = parseStringDef(z.string().time()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'time',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use duration constraint', () => {
-    const parsedSchema = parseStringDef(z.string().duration()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      format: 'duration',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use length constraint', () => {
-    const parsedSchema = parseStringDef(z.string().length(15)._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      minLength: 15,
-      maxLength: 15,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use length with min and max constraints', () => {
-    const parsedSchema = parseStringDef(
-      z.string().min(20).max(25).length(15)._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-      minLength: 20,
-      maxLength: 15,
-    } satisfies JSONSchema7);
-  });
-
-  it('should gracefully ignore the .trim() "check"', () => {
-    const parsedSchema = parseStringDef(z.string().trim()._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-
-  it('should gracefully ignore the .toLowerCase() "check"', () => {
-    const parsedSchema = parseStringDef(
-      z.string().toLowerCase()._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-
-  it('should gracefully ignore the .toUpperCase() "check"', () => {
-    const parsedSchema = parseStringDef(
-      z.string().toUpperCase()._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'string',
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with the startsWith check', () => {
-    expect(
-      parseStringDef(z.string().startsWith('aBcD123{}[]')._def, getRefs()),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: '^aBcD123\\{\\}\\[\\]',
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with the endsWith check', () => {
-    expect(
-      parseStringDef(z.string().endsWith('aBcD123{}[]')._def, getRefs()),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: 'aBcD123\\{\\}\\[\\]$',
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with the includes check', () => {
-    expect(
-      parseStringDef(z.string().includes('aBcD123{}[]')._def, getRefs()),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: 'aBcD123\\{\\}\\[\\]',
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with the preserve patternStrategy', () => {
-    expect(
-      parseStringDef(
-        z.string().includes('aBcD123{}[]')._def,
-        getRefs({
-          patternStrategy: 'preserve',
-        }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: 'aBcD123{}[]',
-    } satisfies JSONSchema7);
-  });
-
-  it('should bundle multiple pattern type checks in an allOf container', () => {
-    expect(
-      parseStringDef(
-        z.string().startsWith('alpha').endsWith('omega')._def,
-        getRefs(),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      allOf: [
-        {
-          pattern: '^alpha',
-        },
-        {
-          pattern: 'omega$',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should pick correct value if multiple min/max are present', () => {
-    expect(
-      parseStringDef(z.string().min(1).min(2).max(3).max(4)._def, getRefs()),
-    ).toStrictEqual({
-      type: 'string',
-      maxLength: 3,
-      minLength: 2,
-    } satisfies JSONSchema7);
-  });
-
-  it('should bundle multiple formats into anyOf', () => {
-    const zodSchema = z.string().ip().email();
-    const jsonParsedSchema = parseStringDef(zodSchema._def, getRefs());
-
-    expect(jsonParsedSchema).toStrictEqual({
-      type: 'string',
-      anyOf: [
-        {
-          format: 'ipv4',
-        },
-        {
-          format: 'ipv6',
-        },
-        {
-          format: 'email',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should default to contentEncoding for base64, but format and pattern should also work', () => {
-    const def = z.string().base64()._def;
-
-    expect(parseStringDef(def, getRefs())).toStrictEqual({
-      type: 'string',
-      contentEncoding: 'base64',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        def,
-        getRefs({ base64Strategy: 'contentEncoding:base64' }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      contentEncoding: 'base64',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(def, getRefs({ base64Strategy: 'format:binary' })),
-    ).toStrictEqual({
-      type: 'string',
-      format: 'binary',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(def, getRefs({ base64Strategy: 'pattern:zod' })),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: zodPatterns.base64.source,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use nanoid constraint', () => {
-    const def = z.string().nanoid()._def;
-
-    expect(parseStringDef(def, getRefs())).toStrictEqual({
-      type: 'string',
-      pattern: '^[a-zA-Z0-9_-]{21}$',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use ulid constraint', () => {
-    const def = z.string().ulid()._def;
-
-    expect(parseStringDef(def, getRefs())).toStrictEqual({
-      type: 'string',
-      pattern: '^[0-9A-HJKMNP-TV-Z]{26}$',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to pick format:email, format:idn-email or pattern:zod', () => {
-    expect(parseStringDef(z.string().email()._def, getRefs())).toStrictEqual({
-      type: 'string',
-      format: 'email',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().email()._def,
-        getRefs({ emailStrategy: 'format:email' }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      format: 'email',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().email()._def,
-        getRefs({ emailStrategy: 'format:idn-email' }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      format: 'idn-email',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().email()._def,
-        getRefs({ emailStrategy: 'pattern:zod' }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: zodPatterns.email.source,
-    } satisfies JSONSchema7);
-  });
-
-  it('should correctly handle reasonable non-contrived regexes with flags', () => {
-    expect(
-      parseStringDef(
-        z.string().regex(/(^|\^foo)Ba[r-z]+./)._def,
-        getRefs({ applyRegexFlags: true }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: '(^|\\^foo)Ba[r-z]+.',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().regex(/(^|\^foo)Ba[r-z]+./i)._def,
-        getRefs({ applyRegexFlags: true }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: '(^|\\^[fF][oO][oO])[bB][aA][r-zR-Z]+.',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().regex(/(^|\^foo)Ba[r-z]+./ms)._def,
-        getRefs({ applyRegexFlags: true }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: '((^|(?<=[\r\n]))|\\^foo)Ba[r-z]+[.\r\n]',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().regex(/(^|\^foo)Ba[r-z]+./ims)._def,
-        getRefs({ applyRegexFlags: true }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: '((^|(?<=[\r\n]))|\\^[fF][oO][oO])[bB][aA][r-zR-Z]+[.\r\n]',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().regex(/foo.+$/m)._def,
-        getRefs({ applyRegexFlags: true }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: 'foo.+($|(?=[\r\n]))',
-    } satisfies JSONSchema7);
-
-    expect(
-      parseStringDef(
-        z.string().regex(/foo.+[amz]/i)._def,
-        getRefs({ applyRegexFlags: true }),
-      ),
-    ).toStrictEqual({
-      type: 'string',
-      pattern: '[fF][oO][oO].+[aAmMzZ]',
-    } satisfies JSONSchema7);
-  });
-
-  it('Unescape forward slashes', () => {
-    const zodSchema = z.string().regex(/^\/$/);
-
-    const jsonSchema = parseStringDef(zodSchema._def, getRefs());
-
-    const pattern = jsonSchema.pattern!;
-    const patternJson = JSON.stringify(pattern);
-    const patternJsonParsed = JSON.parse(patternJson);
-
-    const regexp = new RegExp(patternJsonParsed);
-    expect(regexp.test('')).toBe(false);
-    expect(regexp.test('/')).toBe(true);
-    expect(regexp.test('//')).toBe(false);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.ts
deleted file mode 100644
index 9cc298d..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.ts
+++ /dev/null
@@ -1,426 +0,0 @@
-import { ZodStringDef } from 'zod/v3';
-import { Refs } from '../refs';
-
-let emojiRegex: RegExp | undefined = undefined;
-
-/**
- * Generated from the regular expressions found here as of 2024-05-22:
- * https://github.com/colinhacks/zod/blob/master/src/types.ts.
- *
- * Expressions with /i flag have been changed accordingly.
- */
-export const zodPatterns = {
-  /**
-   * `c` was changed to `[cC]` to replicate /i flag
-   */
-  cuid: /^[cC][^\s-]{8,}$/,
-  cuid2: /^[0-9a-z]+$/,
-  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
-  /**
-   * `a-z` was added to replicate /i flag
-   */
-  email:
-    /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
-  /**
-   * Constructed a valid Unicode RegExp
-   *
-   * Lazily instantiate since this type of regex isn't supported
-   * in all envs (e.g. React Native).
-   *
-   * See:
-   * https://github.com/colinhacks/zod/issues/2433
-   * Fix in Zod:
-   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
-   */
-  emoji: () => {
-    if (emojiRegex === undefined) {
-      emojiRegex = RegExp(
-        '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$',
-        'u',
-      );
-    }
-    return emojiRegex;
-  },
-  /**
-   * Unused
-   */
-  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
-  /**
-   * Unused
-   */
-  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
-  ipv4Cidr:
-    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
-  /**
-   * Unused
-   */
-  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
-  ipv6Cidr:
-    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
-  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
-  base64url:
-    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
-  nanoid: /^[a-zA-Z0-9_-]{21}$/,
-  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
-} as const;
-
-export type JsonSchema7StringType = {
-  type: 'string';
-  minLength?: number;
-  maxLength?: number;
-  format?:
-    | 'email'
-    | 'idn-email'
-    | 'uri'
-    | 'uuid'
-    | 'date-time'
-    | 'ipv4'
-    | 'ipv6'
-    | 'date'
-    | 'time'
-    | 'duration';
-  pattern?: string;
-  allOf?: {
-    pattern: string;
-  }[];
-  anyOf?: {
-    format: string;
-  }[];
-  contentEncoding?: string;
-};
-
-export function parseStringDef(
-  def: ZodStringDef,
-  refs: Refs,
-): JsonSchema7StringType {
-  const res: JsonSchema7StringType = {
-    type: 'string',
-  };
-
-  if (def.checks) {
-    for (const check of def.checks) {
-      switch (check.kind) {
-        case 'min':
-          res.minLength =
-            typeof res.minLength === 'number'
-              ? Math.max(res.minLength, check.value)
-              : check.value;
-          break;
-        case 'max':
-          res.maxLength =
-            typeof res.maxLength === 'number'
-              ? Math.min(res.maxLength, check.value)
-              : check.value;
-
-          break;
-        case 'email':
-          switch (refs.emailStrategy) {
-            case 'format:email':
-              addFormat(res, 'email', check.message, refs);
-              break;
-            case 'format:idn-email':
-              addFormat(res, 'idn-email', check.message, refs);
-              break;
-            case 'pattern:zod':
-              addPattern(res, zodPatterns.email, check.message, refs);
-              break;
-          }
-
-          break;
-        case 'url':
-          addFormat(res, 'uri', check.message, refs);
-          break;
-        case 'uuid':
-          addFormat(res, 'uuid', check.message, refs);
-          break;
-        case 'regex':
-          addPattern(res, check.regex, check.message, refs);
-          break;
-        case 'cuid':
-          addPattern(res, zodPatterns.cuid, check.message, refs);
-          break;
-        case 'cuid2':
-          addPattern(res, zodPatterns.cuid2, check.message, refs);
-          break;
-        case 'startsWith':
-          addPattern(
-            res,
-            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),
-            check.message,
-            refs,
-          );
-          break;
-        case 'endsWith':
-          addPattern(
-            res,
-            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),
-            check.message,
-            refs,
-          );
-          break;
-        case 'datetime':
-          addFormat(res, 'date-time', check.message, refs);
-          break;
-        case 'date':
-          addFormat(res, 'date', check.message, refs);
-          break;
-        case 'time':
-          addFormat(res, 'time', check.message, refs);
-          break;
-        case 'duration':
-          addFormat(res, 'duration', check.message, refs);
-          break;
-        case 'length':
-          res.minLength =
-            typeof res.minLength === 'number'
-              ? Math.max(res.minLength, check.value)
-              : check.value;
-          res.maxLength =
-            typeof res.maxLength === 'number'
-              ? Math.min(res.maxLength, check.value)
-              : check.value;
-          break;
-        case 'includes': {
-          addPattern(
-            res,
-            RegExp(escapeLiteralCheckValue(check.value, refs)),
-            check.message,
-            refs,
-          );
-          break;
-        }
-        case 'ip': {
-          if (check.version !== 'v6') {
-            addFormat(res, 'ipv4', check.message, refs);
-          }
-          if (check.version !== 'v4') {
-            addFormat(res, 'ipv6', check.message, refs);
-          }
-          break;
-        }
-        case 'base64url':
-          addPattern(res, zodPatterns.base64url, check.message, refs);
-          break;
-        case 'jwt':
-          addPattern(res, zodPatterns.jwt, check.message, refs);
-          break;
-        case 'cidr': {
-          if (check.version !== 'v6') {
-            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
-          }
-          if (check.version !== 'v4') {
-            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
-          }
-          break;
-        }
-        case 'emoji':
-          addPattern(res, zodPatterns.emoji(), check.message, refs);
-          break;
-        case 'ulid': {
-          addPattern(res, zodPatterns.ulid, check.message, refs);
-          break;
-        }
-        case 'base64': {
-          switch (refs.base64Strategy) {
-            case 'format:binary': {
-              addFormat(res, 'binary' as any, check.message, refs);
-              break;
-            }
-
-            case 'contentEncoding:base64': {
-              res.contentEncoding = 'base64';
-              break;
-            }
-
-            case 'pattern:zod': {
-              addPattern(res, zodPatterns.base64, check.message, refs);
-              break;
-            }
-          }
-          break;
-        }
-        case 'nanoid': {
-          addPattern(res, zodPatterns.nanoid, check.message, refs);
-        }
-        case 'toLowerCase':
-        case 'toUpperCase':
-        case 'trim':
-          break;
-        default:
-          /* c8 ignore next */
-          ((_: never) => {})(check);
-      }
-    }
-  }
-
-  return res;
-}
-
-function escapeLiteralCheckValue(literal: string, refs: Refs): string {
-  return refs.patternStrategy === 'escape'
-    ? escapeNonAlphaNumeric(literal)
-    : literal;
-}
-
-const ALPHA_NUMERIC = new Set(
-  'ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789',
-);
-
-function escapeNonAlphaNumeric(source: string) {
-  let result = '';
-
-  for (let i = 0; i < source.length; i++) {
-    if (!ALPHA_NUMERIC.has(source[i])) {
-      result += '\\';
-    }
-
-    result += source[i];
-  }
-
-  return result;
-}
-
-// Adds a "format" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.
-function addFormat(
-  schema: JsonSchema7StringType,
-  value: Required<JsonSchema7StringType>['format'],
-  message: string | undefined,
-  refs: Refs,
-) {
-  if (schema.format || schema.anyOf?.some(x => x.format)) {
-    if (!schema.anyOf) {
-      schema.anyOf = [];
-    }
-
-    if (schema.format) {
-      schema.anyOf!.push({
-        format: schema.format,
-      });
-      delete schema.format;
-    }
-
-    schema.anyOf!.push({
-      format: value,
-      ...(message &&
-        refs.errorMessages && { errorMessage: { format: message } }),
-    });
-  } else {
-    schema.format = value;
-  }
-}
-
-// Adds a "pattern" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.
-function addPattern(
-  schema: JsonSchema7StringType,
-  regex: RegExp,
-  message: string | undefined,
-  refs: Refs,
-) {
-  if (schema.pattern || schema.allOf?.some(x => x.pattern)) {
-    if (!schema.allOf) {
-      schema.allOf = [];
-    }
-
-    if (schema.pattern) {
-      schema.allOf!.push({
-        pattern: schema.pattern,
-      });
-      delete schema.pattern;
-    }
-
-    schema.allOf!.push({
-      pattern: stringifyRegExpWithFlags(regex, refs),
-      ...(message &&
-        refs.errorMessages && { errorMessage: { pattern: message } }),
-    });
-  } else {
-    schema.pattern = stringifyRegExpWithFlags(regex, refs);
-  }
-}
-
-// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true
-function stringifyRegExpWithFlags(regex: RegExp, refs: Refs): string {
-  if (!refs.applyRegexFlags || !regex.flags) {
-    return regex.source;
-  }
-
-  // Currently handled flags
-  const flags = {
-    i: regex.flags.includes('i'), // Case-insensitive
-    m: regex.flags.includes('m'), // `^` and `$` matches adjacent to newline characters
-    s: regex.flags.includes('s'), // `.` matches newlines
-  };
-
-  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!
-  const source = flags.i ? regex.source.toLowerCase() : regex.source;
-  let pattern = '';
-  let isEscaped = false;
-  let inCharGroup = false;
-  let inCharRange = false;
-
-  for (let i = 0; i < source.length; i++) {
-    if (isEscaped) {
-      pattern += source[i];
-      isEscaped = false;
-      continue;
-    }
-
-    if (flags.i) {
-      if (inCharGroup) {
-        if (source[i].match(/[a-z]/)) {
-          if (inCharRange) {
-            pattern += source[i];
-            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
-            inCharRange = false;
-          } else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {
-            pattern += source[i];
-            inCharRange = true;
-          } else {
-            pattern += `${source[i]}${source[i].toUpperCase()}`;
-          }
-          continue;
-        }
-      } else if (source[i].match(/[a-z]/)) {
-        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
-        continue;
-      }
-    }
-
-    if (flags.m) {
-      if (source[i] === '^') {
-        pattern += `(^|(?<=[\r\n]))`;
-        continue;
-      } else if (source[i] === '$') {
-        pattern += `($|(?=[\r\n]))`;
-        continue;
-      }
-    }
-
-    if (flags.s && source[i] === '.') {
-      pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
-      continue;
-    }
-
-    pattern += source[i];
-    if (source[i] === '\\') {
-      isEscaped = true;
-    } else if (inCharGroup && source[i] === ']') {
-      inCharGroup = false;
-    } else if (!inCharGroup && source[i] === '[') {
-      inCharGroup = true;
-    }
-  }
-
-  try {
-    new RegExp(pattern);
-  } catch {
-    console.warn(
-      `Could not convert regex pattern at ${refs.currentPath.join(
-        '/',
-      )} to a flag-independent form! Falling back to the flag-ignorant source`,
-    );
-    return regex.source;
-  }
-
-  return pattern;
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.test.ts
deleted file mode 100644
index f887105..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.test.ts
+++ /dev/null
@@ -1,33 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseTupleDef } from './tuple';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('tuple', () => {
-  it('should be possible to describe a simple tuple schema', () => {
-    const schema = z.tuple([z.string(), z.number()]);
-    const parsedSchema = parseTupleDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      items: [{ type: 'string' }, { type: 'number' }],
-      minItems: 2,
-      maxItems: 2,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to describe a tuple schema with rest()', () => {
-    const schema = z.tuple([z.string(), z.number()]).rest(z.boolean());
-    const parsedSchema = parseTupleDef(schema._def, getRefs());
-
-    expect(parsedSchema).toStrictEqual({
-      type: 'array',
-      items: [{ type: 'string' }, { type: 'number' }],
-      minItems: 2,
-      additionalItems: {
-        type: 'boolean',
-      },
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts
deleted file mode 100644
index 9a05c94..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts
+++ /dev/null
@@ -1,61 +0,0 @@
-import { ZodTupleDef, ZodTupleItems, ZodTypeAny } from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export type JsonSchema7TupleType = {
-  type: 'array';
-  minItems: number;
-  items: JsonSchema7Type[];
-} & (
-  | {
-      maxItems: number;
-    }
-  | {
-      additionalItems?: JsonSchema7Type;
-    }
-);
-
-export function parseTupleDef(
-  def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>,
-  refs: Refs,
-): JsonSchema7TupleType {
-  if (def.rest) {
-    return {
-      type: 'array',
-      minItems: def.items.length,
-      items: def.items
-        .map((x, i) =>
-          parseDef(x._def, {
-            ...refs,
-            currentPath: [...refs.currentPath, 'items', `${i}`],
-          }),
-        )
-        .reduce(
-          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),
-          [],
-        ),
-      additionalItems: parseDef(def.rest._def, {
-        ...refs,
-        currentPath: [...refs.currentPath, 'additionalItems'],
-      }),
-    };
-  } else {
-    return {
-      type: 'array',
-      minItems: def.items.length,
-      maxItems: def.items.length,
-      items: def.items
-        .map((x, i) =>
-          parseDef(x._def, {
-            ...refs,
-            currentPath: [...refs.currentPath, 'items', `${i}`],
-          }),
-        )
-        .reduce(
-          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),
-          [],
-        ),
-    };
-  }
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts
deleted file mode 100644
index 0d18409..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-import { JsonSchema7AnyType, parseAnyDef } from './any';
-
-export type JsonSchema7UndefinedType = {
-  not: JsonSchema7AnyType;
-};
-
-export function parseUndefinedDef(): JsonSchema7UndefinedType {
-  return {
-    not: parseAnyDef(),
-  };
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.test.ts
deleted file mode 100644
index fdb92d6..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.test.ts
+++ /dev/null
@@ -1,226 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { z } from 'zod/v3';
-import { parseUnionDef } from './union';
-import { getRefs } from '../refs';
-import { JSONSchema7 } from '@ai-sdk/provider';
-
-describe('union', () => {
-  it('Should be possible to get a simple type array from a union of only unvalidated primitives', () => {
-    const parsedSchema = parseUnionDef(
-      z.union([z.string(), z.number(), z.boolean(), z.null()])._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: ['string', 'number', 'boolean', 'null'],
-    } satisfies JSONSchema7);
-  });
-
-  it('Should be possible to get a simple type array with enum values from a union of literals', () => {
-    const parsedSchema = parseUnionDef(
-      z.union([
-        z.literal('string'),
-        z.literal(123),
-        z.literal(true),
-        z.literal(null),
-        z.literal(BigInt(50)),
-      ])._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      type: ['string', 'number', 'boolean', 'null', 'integer'],
-      enum: ['string', 123, true, null, BigInt(50) as unknown as number],
-    } satisfies JSONSchema7);
-  });
-
-  it('Should be possible to get an anyOf array with enum values from a union of literals', () => {
-    const parsedSchema = parseUnionDef(
-      z.union([
-        z.literal(undefined),
-        z.literal(Symbol('abc')),
-        // @ts-expect-error Ok
-        z.literal(function () {}),
-      ])._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      anyOf: [
-        {
-          type: 'object',
-        },
-        {
-          type: 'object',
-        },
-        {
-          type: 'object',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('Should be possible to create a union with objects, arrays and validated primitives as an anyOf', () => {
-    const parsedSchema = parseUnionDef(
-      z.union([
-        z.object({ herp: z.string(), derp: z.boolean() }),
-        z.array(z.number()),
-        z.string().min(3),
-        z.number(),
-      ])._def,
-      getRefs(),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      anyOf: [
-        {
-          type: 'object',
-          properties: {
-            herp: {
-              type: 'string',
-            },
-            derp: {
-              type: 'boolean',
-            },
-          },
-          required: ['herp', 'derp'],
-          additionalProperties: false,
-        },
-        {
-          type: 'array',
-          items: {
-            type: 'number',
-          },
-        },
-        {
-          type: 'string',
-          minLength: 3,
-        },
-        {
-          type: 'number',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to deref union schemas', () => {
-    const recurring = z.object({ foo: z.boolean() });
-
-    const union = z.union([recurring, recurring, recurring]);
-
-    const jsonSchema = parseUnionDef(union._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      anyOf: [
-        {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'boolean',
-            },
-          },
-          required: ['foo'],
-          additionalProperties: false,
-        },
-        {
-          $ref: '#/anyOf/0',
-        },
-        {
-          $ref: '#/anyOf/0',
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('nullable primitives should come out fine', () => {
-    const union = z.union([z.string(), z.null()]);
-
-    const jsonSchema = parseUnionDef(union._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      type: ['string', 'null'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should join a union of Zod enums into a single enum', () => {
-    const union = z.union([z.enum(['a', 'b', 'c']), z.enum(['c', 'd', 'e'])]);
-
-    const jsonSchema = parseUnionDef(union._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      type: 'string',
-      enum: ['a', 'b', 'c', 'd', 'e'],
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with discriminated union type', () => {
-    const discUnion = z.discriminatedUnion('kek', [
-      z.object({ kek: z.literal('A'), lel: z.boolean() }),
-      z.object({ kek: z.literal('B'), lel: z.number() }),
-    ]);
-
-    const jsonSchema = parseUnionDef(discUnion._def, getRefs());
-
-    expect(jsonSchema).toStrictEqual({
-      anyOf: [
-        {
-          type: 'object',
-          properties: {
-            kek: {
-              type: 'string',
-              const: 'A',
-            },
-            lel: {
-              type: 'boolean',
-            },
-          },
-          required: ['kek', 'lel'],
-          additionalProperties: false,
-        },
-        {
-          type: 'object',
-          properties: {
-            kek: {
-              type: 'string',
-              const: 'B',
-            },
-            lel: {
-              type: 'number',
-            },
-          },
-          required: ['kek', 'lel'],
-          additionalProperties: false,
-        },
-      ],
-    } satisfies JSONSchema7);
-  });
-
-  it('should not ignore descriptions in literal unions', () => {
-    expect(
-      parseUnionDef(
-        z.union([z.literal(true), z.literal('herp'), z.literal(3)])._def,
-        getRefs(),
-      ),
-    ).toStrictEqual({
-      type: ['boolean', 'string', 'number'],
-      enum: [true, 'herp', 3],
-    } satisfies JSONSchema7);
-
-    expect(
-      parseUnionDef(
-        z.union([
-          z.literal(true),
-          z.literal('herp').describe('derp'),
-          z.literal(3),
-        ])._def,
-        getRefs(),
-      ),
-    ).toStrictEqual({
-      anyOf: [
-        { type: 'boolean', const: true },
-        { type: 'string', const: 'herp', description: 'derp' },
-        { type: 'number', const: 3 },
-      ],
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.ts
deleted file mode 100644
index 35730ea..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.ts
+++ /dev/null
@@ -1,144 +0,0 @@
-import {
-  ZodDiscriminatedUnionDef,
-  ZodLiteralDef,
-  ZodTypeAny,
-  ZodUnionDef,
-} from 'zod/v3';
-import { parseDef } from '../parse-def';
-import { JsonSchema7Type } from '../parse-types';
-import { Refs } from '../refs';
-
-export const primitiveMappings = {
-  ZodString: 'string',
-  ZodNumber: 'number',
-  ZodBigInt: 'integer',
-  ZodBoolean: 'boolean',
-  ZodNull: 'null',
-} as const;
-type ZodPrimitive = keyof typeof primitiveMappings;
-type JsonSchema7Primitive =
-  (typeof primitiveMappings)[keyof typeof primitiveMappings];
-
-export type JsonSchema7UnionType =
-  | JsonSchema7PrimitiveUnionType
-  | JsonSchema7AnyOfType;
-
-type JsonSchema7PrimitiveUnionType =
-  | {
-      type: JsonSchema7Primitive | JsonSchema7Primitive[];
-    }
-  | {
-      type: JsonSchema7Primitive | JsonSchema7Primitive[];
-      enum: (string | number | bigint | boolean | null)[];
-    };
-
-type JsonSchema7AnyOfType = {
-  anyOf: JsonSchema7Type[];
-};
-
-export function parseUnionDef(
-  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,
-  refs: Refs,
-): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined {
-  const options: readonly ZodTypeAny[] =
-    def.options instanceof Map ? Array.from(def.options.values()) : def.options;
-
-  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.
-  if (
-    options.every(
-      x =>
-        x._def.typeName in primitiveMappings &&
-        (!x._def.checks || !x._def.checks.length),
-    )
-  ) {
-    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}
-
-    const types = options.reduce((types: JsonSchema7Primitive[], x) => {
-      const type = primitiveMappings[x._def.typeName as ZodPrimitive]; //Can be safely casted due to row 43
-      return type && !types.includes(type) ? [...types, type] : types;
-    }, []);
-
-    return {
-      type: types.length > 1 ? types : types[0],
-    };
-  } else if (
-    options.every(x => x._def.typeName === 'ZodLiteral' && !x.description)
-  ) {
-    // all options literals
-
-    const types = options.reduce(
-      (acc: JsonSchema7Primitive[], x: { _def: ZodLiteralDef }) => {
-        const type = typeof x._def.value;
-        switch (type) {
-          case 'string':
-          case 'number':
-          case 'boolean':
-            return [...acc, type];
-          case 'bigint':
-            return [...acc, 'integer' as const];
-          case 'object':
-            if (x._def.value === null) return [...acc, 'null' as const];
-          case 'symbol':
-          case 'undefined':
-          case 'function':
-          default:
-            return acc;
-        }
-      },
-      [],
-    );
-
-    if (types.length === options.length) {
-      // all the literals are primitive, as far as null can be considered primitive
-
-      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
-      return {
-        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
-        enum: options.reduce(
-          (acc, x) => {
-            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
-          },
-          [] as (string | number | bigint | boolean | null)[],
-        ),
-      };
-    }
-  } else if (options.every(x => x._def.typeName === 'ZodEnum')) {
-    return {
-      type: 'string',
-      enum: options.reduce(
-        (acc: string[], x) => [
-          ...acc,
-          ...x._def.values.filter((x: string) => !acc.includes(x)),
-        ],
-        [],
-      ),
-    };
-  }
-
-  return asAnyOf(def, refs);
-}
-
-const asAnyOf = (
-  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,
-  refs: Refs,
-): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined => {
-  const anyOf = (
-    (def.options instanceof Map
-      ? Array.from(def.options.values())
-      : def.options) as any[]
-  )
-    .map((x, i) =>
-      parseDef(x._def, {
-        ...refs,
-        currentPath: [...refs.currentPath, 'anyOf', `${i}`],
-      }),
-    )
-    .filter(
-      (x): x is JsonSchema7Type =>
-        !!x &&
-        (!refs.strictUnions ||
-          (typeof x === 'object' && Object.keys(x).length > 0)),
-    );
-
-  return anyOf.length ? { anyOf } : undefined;
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts
deleted file mode 100644
index 946a367..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { JsonSchema7AnyType, parseAnyDef } from './any';
-
-export type JsonSchema7UnknownType = JsonSchema7AnyType;
-
-export function parseUnknownDef(): JsonSchema7UnknownType {
-  return parseAnyDef();
-}
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.test.ts
deleted file mode 100644
index 25f0641..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.test.ts
+++ /dev/null
@@ -1,919 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import { zod3ToJsonSchema } from './zod3-to-json-schema';
-
-describe('paths', () => {
-  it('should handle recurring properties with paths', () => {
-    const addressSchema = z.object({
-      street: z.string(),
-      number: z.number(),
-      city: z.string(),
-    });
-    const someAddresses = z.object({
-      address1: addressSchema,
-      address2: addressSchema,
-      lotsOfAddresses: z.array(addressSchema),
-    });
-
-    const parsedSchema = zod3ToJsonSchema(someAddresses);
-
-    expect(parsedSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        address1: {
-          type: 'object',
-          properties: {
-            street: { type: 'string' },
-            number: { type: 'number' },
-            city: { type: 'string' },
-          },
-          additionalProperties: false,
-          required: ['street', 'number', 'city'],
-        },
-        address2: { $ref: '#/properties/address1' },
-        lotsOfAddresses: {
-          type: 'array',
-          items: { $ref: '#/properties/address1' },
-        },
-      },
-      additionalProperties: false,
-      required: ['address1', 'address2', 'lotsOfAddresses'],
-    } satisfies JSONSchema7);
-  });
-
-  it('Should properly reference union participants', () => {
-    const participant = z.object({ str: z.string() });
-
-    const schema = z.object({
-      union: z.union([participant, z.string()]),
-      part: participant,
-    });
-
-    const parsedSchema = zod3ToJsonSchema(schema);
-
-    expect(parsedSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        union: {
-          anyOf: [
-            {
-              type: 'object',
-              properties: {
-                str: {
-                  type: 'string',
-                },
-              },
-              additionalProperties: false,
-              required: ['str'],
-            },
-            {
-              type: 'string',
-            },
-          ],
-        },
-        part: {
-          $ref: '#/properties/union/anyOf/0',
-        },
-      },
-      additionalProperties: false,
-      required: ['union', 'part'],
-    } satisfies JSONSchema7);
-  });
-
-  it('Should be able to handle recursive schemas', () => {
-    type Category = {
-      name: string;
-      subcategories: Category[];
-    };
-
-    // cast to z.ZodSchema<Category>
-    // @ts-ignore
-    const categorySchema: z.ZodSchema<Category> = z.lazy(() =>
-      z.object({
-        name: z.string(),
-        subcategories: z.array(categorySchema),
-      }),
-    );
-
-    const parsedSchema = zod3ToJsonSchema(categorySchema);
-
-    expect(parsedSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        name: {
-          type: 'string',
-        },
-        subcategories: {
-          type: 'array',
-          items: {
-            $ref: '#',
-          },
-        },
-      },
-      required: ['name', 'subcategories'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('Should be able to handle complex & nested recursive schemas', () => {
-    type Category = {
-      name: string;
-      inner: {
-        subcategories?: Record<string, Category> | null;
-      };
-    };
-
-    // cast to z.ZodSchema<Category>
-    // @ts-ignore
-    const categorySchema: z.ZodSchema<Category> = z.lazy(() =>
-      z.object({
-        name: z.string(),
-        inner: z.object({
-          subcategories: z.record(categorySchema).nullable().optional(),
-        }),
-      }),
-    );
-
-    const inObjectSchema = z.object({
-      category: categorySchema,
-    });
-
-    const parsedSchema = zod3ToJsonSchema(inObjectSchema);
-
-    expect(parsedSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      additionalProperties: false,
-      required: ['category'],
-      properties: {
-        category: {
-          type: 'object',
-          properties: {
-            name: {
-              type: 'string',
-            },
-            inner: {
-              type: 'object',
-              additionalProperties: false,
-              properties: {
-                subcategories: {
-                  anyOf: [
-                    {
-                      type: 'object',
-                      additionalProperties: {
-                        $ref: '#/properties/category',
-                      },
-                    },
-                    {
-                      type: 'null',
-                    },
-                  ],
-                },
-              },
-            },
-          },
-          required: ['name', 'inner'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should work with relative references', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, {
-      $refStrategy: 'relative',
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        foo: {
-          type: 'string',
-        },
-        bar: {
-          $ref: '1/foo',
-        },
-      },
-      required: ['foo', 'bar'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to override the base path', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, {
-      basePath: ['#', 'lol', 'xD'],
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        foo: {
-          type: 'string',
-        },
-        bar: {
-          $ref: '#/lol/xD/properties/foo',
-        },
-      },
-      required: ['foo', 'bar'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to override the base path with name', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, {
-      basePath: ['#', 'lol', 'xD'],
-      name: 'kex',
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/lol/xD/definitions/kex',
-      definitions: {
-        kex: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              $ref: '#/lol/xD/definitions/kex/properties/foo',
-            },
-          },
-          required: ['foo', 'bar'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to opt out of $ref building', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, {
-      $refStrategy: 'none',
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        foo: {
-          type: 'string',
-        },
-        bar: {
-          type: 'string',
-        },
-      },
-      required: ['foo', 'bar'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('When opting out of ref building and using recursive schemas, should warn and default to any', () => {
-    const was = console.warn;
-    let warning = '';
-    console.warn = (x: any) => (warning = x);
-
-    type Category = {
-      name: string;
-      subcategories: Category[];
-    };
-
-    // cast to z.ZodSchema<Category>
-    // @ts-ignore
-    const categorySchema: z.ZodSchema<Category> = z.lazy(() =>
-      z.object({
-        name: z.string(),
-        subcategories: z.array(categorySchema),
-      }),
-    );
-
-    const parsedSchema = zod3ToJsonSchema(categorySchema, {
-      $refStrategy: 'none',
-    });
-
-    expect(parsedSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        name: {
-          type: 'string',
-        },
-        subcategories: {
-          type: 'array',
-          items: {},
-        },
-      },
-      required: ['name', 'subcategories'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-
-    expect(warning).toBe(
-      'Recursive reference detected at #/properties/subcategories/items! Defaulting to any',
-    );
-
-    console.warn = was;
-  });
-
-  it('should be possible to override get proper references even when picking optional definitions path $defs', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, {
-      name: 'hello',
-      definitionPath: '$defs',
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/$defs/hello',
-      $defs: {
-        hello: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              $ref: '#/$defs/hello/properties/foo',
-            },
-          },
-          required: ['foo', 'bar'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to override get proper references even when picking optional definitions path definitions', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, {
-      name: 'hello',
-      definitionPath: 'definitions',
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/definitions/hello',
-      definitions: {
-        hello: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              $ref: '#/definitions/hello/properties/foo',
-            },
-          },
-          required: ['foo', 'bar'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should preserve correct $ref when overriding name with string', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, 'hello');
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/definitions/hello',
-      definitions: {
-        hello: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              $ref: '#/definitions/hello/properties/foo',
-            },
-          },
-          required: ['foo', 'bar'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should preserve correct $ref when overriding name with object property', () => {
-    const recurringSchema = z.string();
-    const objectSchema = z.object({
-      foo: recurringSchema,
-      bar: recurringSchema,
-    });
-
-    const jsonSchema = zod3ToJsonSchema(objectSchema, { name: 'hello' });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/definitions/hello',
-      definitions: {
-        hello: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              $ref: '#/definitions/hello/properties/foo',
-            },
-          },
-          required: ['foo', 'bar'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to preload a single definition', () => {
-    const myRecurringSchema = z.string();
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: myRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema },
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      required: ['a', 'b'],
-      properties: {
-        a: {
-          $ref: '#/definitions/myRecurringSchema',
-        },
-        b: {
-          $ref: '#/definitions/myRecurringSchema',
-        },
-      },
-      additionalProperties: false,
-      definitions: {
-        myRecurringSchema: {
-          type: 'string',
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to preload multiple definitions', () => {
-    const myRecurringSchema = z.string();
-    const mySecondRecurringSchema = z.object({
-      x: myRecurringSchema,
-    });
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: mySecondRecurringSchema,
-      c: mySecondRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema, mySecondRecurringSchema },
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      required: ['a', 'b', 'c'],
-      properties: {
-        a: {
-          $ref: '#/definitions/myRecurringSchema',
-        },
-        b: {
-          $ref: '#/definitions/mySecondRecurringSchema',
-        },
-        c: {
-          $ref: '#/definitions/mySecondRecurringSchema',
-        },
-      },
-      additionalProperties: false,
-      definitions: {
-        myRecurringSchema: {
-          type: 'string',
-        },
-        mySecondRecurringSchema: {
-          type: 'object',
-          required: ['x'],
-          properties: {
-            x: {
-              $ref: '#/definitions/myRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to preload multiple definitions and have a named schema', () => {
-    const myRecurringSchema = z.string();
-    const mySecondRecurringSchema = z.object({
-      x: myRecurringSchema,
-    });
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: mySecondRecurringSchema,
-      c: mySecondRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema, mySecondRecurringSchema },
-      name: 'mySchemaName',
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/definitions/mySchemaName',
-      definitions: {
-        mySchemaName: {
-          type: 'object',
-          required: ['a', 'b', 'c'],
-          properties: {
-            a: {
-              $ref: '#/definitions/myRecurringSchema',
-            },
-            b: {
-              $ref: '#/definitions/mySecondRecurringSchema',
-            },
-            c: {
-              $ref: '#/definitions/mySecondRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-        myRecurringSchema: {
-          type: 'string',
-        },
-        mySecondRecurringSchema: {
-          type: 'object',
-          required: ['x'],
-          properties: {
-            x: {
-              $ref: '#/definitions/myRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to preload multiple definitions and have a named schema and set the definitions path', () => {
-    const myRecurringSchema = z.string();
-    const mySecondRecurringSchema = z.object({
-      x: myRecurringSchema,
-    });
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: mySecondRecurringSchema,
-      c: mySecondRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema, mySecondRecurringSchema },
-      name: 'mySchemaName',
-      definitionPath: '$defs',
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/$defs/mySchemaName',
-      $defs: {
-        mySchemaName: {
-          type: 'object',
-          required: ['a', 'b', 'c'],
-          properties: {
-            a: {
-              $ref: '#/$defs/myRecurringSchema',
-            },
-            b: {
-              $ref: '#/$defs/mySecondRecurringSchema',
-            },
-            c: {
-              $ref: '#/$defs/mySecondRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-        myRecurringSchema: {
-          type: 'string',
-        },
-        mySecondRecurringSchema: {
-          type: 'object',
-          required: ['x'],
-          properties: {
-            x: {
-              $ref: '#/$defs/myRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to preload a single definition with custom basePath', () => {
-    const myRecurringSchema = z.string();
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: myRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema },
-      basePath: ['hello'],
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      required: ['a', 'b'],
-      properties: {
-        a: {
-          $ref: 'hello/definitions/myRecurringSchema',
-        },
-        b: {
-          $ref: 'hello/definitions/myRecurringSchema',
-        },
-      },
-      additionalProperties: false,
-      definitions: {
-        myRecurringSchema: {
-          type: 'string',
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to preload a single definition with custom basePath and name', () => {
-    const myRecurringSchema = z.string();
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: myRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema },
-      basePath: ['hello'],
-      name: 'kex',
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: 'hello/definitions/kex',
-      definitions: {
-        kex: {
-          type: 'object',
-          required: ['a', 'b'],
-          properties: {
-            a: {
-              $ref: 'hello/definitions/myRecurringSchema',
-            },
-            b: {
-              $ref: 'hello/definitions/myRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-        myRecurringSchema: {
-          type: 'string',
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible for a preloaded definition to circularly reference itself', () => {
-    const myRecurringSchema: any = z.object({
-      circular: z.lazy(() => myRecurringSchema),
-    });
-
-    const myObjectSchema = z.object({
-      a: myRecurringSchema,
-      b: myRecurringSchema,
-    });
-
-    const myJsonSchema = zod3ToJsonSchema(myObjectSchema, {
-      definitions: { myRecurringSchema },
-      basePath: ['hello'],
-      name: 'kex',
-    });
-
-    expect(myJsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: 'hello/definitions/kex',
-      definitions: {
-        kex: {
-          type: 'object',
-          required: ['a', 'b'],
-          properties: {
-            a: {
-              $ref: 'hello/definitions/myRecurringSchema',
-            },
-            b: {
-              $ref: 'hello/definitions/myRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-        myRecurringSchema: {
-          type: 'object',
-          required: ['circular'],
-          properties: {
-            circular: {
-              $ref: 'hello/definitions/myRecurringSchema',
-            },
-          },
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should handle the user example', () => {
-    interface User {
-      id: string;
-      headUser?: User;
-    }
-
-    const userSchema: z.ZodType<User> = z.lazy(() =>
-      z.object({
-        id: z.string(),
-        headUser: userSchema.optional(),
-      }),
-    );
-
-    const schema = z.object({ user: userSchema });
-
-    expect(
-      zod3ToJsonSchema(schema, {
-        definitions: { userSchema },
-      }),
-    ).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        user: {
-          $ref: '#/definitions/userSchema',
-        },
-      },
-      required: ['user'],
-      additionalProperties: false,
-      definitions: {
-        userSchema: {
-          type: 'object',
-          properties: {
-            id: {
-              type: 'string',
-            },
-            headUser: {
-              $ref: '#/definitions/userSchema',
-            },
-          },
-          required: ['id'],
-          additionalProperties: false,
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should handle mutual recursion', () => {
-    const leafSchema = z.object({
-      prop: z.string(),
-    });
-
-    let nodeChildSchema: z.ZodType;
-
-    const nodeSchema = z.object({
-      children: z.lazy(() => z.array(nodeChildSchema)),
-    });
-
-    nodeChildSchema = z.union([leafSchema, nodeSchema]);
-
-    const treeSchema = z.object({
-      nodes: nodeSchema,
-    });
-
-    expect(
-      zod3ToJsonSchema(treeSchema, {
-        name: 'Tree',
-        definitions: {
-          Leaf: leafSchema,
-          NodeChild: nodeChildSchema,
-          Node: nodeSchema,
-        },
-      }),
-    ).toStrictEqual({
-      $ref: '#/definitions/Tree',
-      definitions: {
-        Leaf: {
-          type: 'object',
-          properties: {
-            prop: {
-              type: 'string',
-            },
-          },
-          required: ['prop'],
-          additionalProperties: false,
-        },
-        Node: {
-          type: 'object',
-          properties: {
-            children: {
-              type: 'array',
-              items: {
-                $ref: '#/definitions/NodeChild',
-              },
-            },
-          },
-          required: ['children'],
-          additionalProperties: false,
-        },
-        NodeChild: {
-          anyOf: [
-            {
-              $ref: '#/definitions/Leaf',
-            },
-            {
-              $ref: '#/definitions/Node',
-            },
-          ],
-        },
-        Tree: {
-          type: 'object',
-          properties: {
-            nodes: {
-              $ref: '#/definitions/Node',
-            },
-          },
-          required: ['nodes'],
-          additionalProperties: false,
-        },
-      },
-      $schema: 'http://json-schema.org/draft-07/schema#',
-    } satisfies JSONSchema7);
-  });
-
-  it('should not fail when definition is lazy', () => {
-    const lazyString = z.lazy(() => z.string());
-
-    const lazyObject = z.lazy(() => z.object({ lazyProp: lazyString }));
-
-    const jsonSchema = zod3ToJsonSchema(lazyObject, {
-      definitions: { lazyString },
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      type: 'object',
-      properties: { lazyProp: { $ref: '#/definitions/lazyString' } },
-      required: ['lazyProp'],
-      additionalProperties: false,
-      definitions: { lazyString: { type: 'string' } },
-      $schema: 'http://json-schema.org/draft-07/schema#',
-    } satisfies JSONSchema7);
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.ts
deleted file mode 100644
index b951d05..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-import { ZodTypeDef } from 'zod/v3';
-import { getDefaultOptions, Options } from './options';
-import { JsonSchema7Type } from './parse-types';
-
-export type Refs = {
-  seen: Map<ZodTypeDef, Seen>;
-  currentPath: string[];
-  propertyPath: string[] | undefined;
-} & Options;
-
-export type Seen = {
-  def: ZodTypeDef;
-  path: string[];
-  jsonSchema: JsonSchema7Type | undefined;
-};
-
-export const getRefs = (options?: string | Partial<Options>): Refs => {
-  const _options = getDefaultOptions(options);
-  const currentPath =
-    _options.name !== undefined
-      ? [..._options.basePath, _options.definitionPath, _options.name]
-      : _options.basePath;
-  return {
-    ..._options,
-    currentPath: currentPath,
-    propertyPath: undefined,
-    seen: new Map(
-      Object.entries(_options.definitions).map(([name, def]) => [
-        def._def,
-        {
-          def: def._def,
-          path: [..._options.basePath, _options.definitionPath, name],
-          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
-          jsonSchema: undefined,
-        },
-      ]),
-    ),
-  };
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/select-parser.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/select-parser.ts
deleted file mode 100644
index b0ee337..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/select-parser.ts
+++ /dev/null
@@ -1,115 +0,0 @@
-import { ZodFirstPartyTypeKind } from 'zod/v3';
-import { parseAnyDef } from './parsers/any';
-import { parseArrayDef } from './parsers/array';
-import { parseBigintDef } from './parsers/bigint';
-import { parseBooleanDef } from './parsers/boolean';
-import { parseBrandedDef } from './parsers/branded';
-import { parseCatchDef } from './parsers/catch';
-import { parseDateDef } from './parsers/date';
-import { parseDefaultDef } from './parsers/default';
-import { parseEffectsDef } from './parsers/effects';
-import { parseEnumDef } from './parsers/enum';
-import { parseIntersectionDef } from './parsers/intersection';
-import { parseLiteralDef } from './parsers/literal';
-import { parseMapDef } from './parsers/map';
-import { parseNativeEnumDef } from './parsers/native-enum';
-import { parseNeverDef } from './parsers/never';
-import { parseNullDef } from './parsers/null';
-import { parseNullableDef } from './parsers/nullable';
-import { parseNumberDef } from './parsers/number';
-import { parseObjectDef } from './parsers/object';
-import { parseOptionalDef } from './parsers/optional';
-import { parsePipelineDef } from './parsers/pipeline';
-import { parsePromiseDef } from './parsers/promise';
-import { parseRecordDef } from './parsers/record';
-import { parseSetDef } from './parsers/set';
-import { parseStringDef } from './parsers/string';
-import { parseTupleDef } from './parsers/tuple';
-import { parseUndefinedDef } from './parsers/undefined';
-import { parseUnionDef } from './parsers/union';
-import { parseUnknownDef } from './parsers/unknown';
-import { Refs } from './refs';
-import { parseReadonlyDef } from './parsers/readonly';
-import { JsonSchema7Type } from './parse-types';
-
-export type InnerDefGetter = () => any;
-
-export const selectParser = (
-  def: any,
-  typeName: ZodFirstPartyTypeKind,
-  refs: Refs,
-): JsonSchema7Type | undefined | InnerDefGetter => {
-  switch (typeName) {
-    case ZodFirstPartyTypeKind.ZodString:
-      return parseStringDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodNumber:
-      return parseNumberDef(def);
-    case ZodFirstPartyTypeKind.ZodObject:
-      return parseObjectDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodBigInt:
-      return parseBigintDef(def);
-    case ZodFirstPartyTypeKind.ZodBoolean:
-      return parseBooleanDef();
-    case ZodFirstPartyTypeKind.ZodDate:
-      return parseDateDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodUndefined:
-      return parseUndefinedDef();
-    case ZodFirstPartyTypeKind.ZodNull:
-      return parseNullDef();
-    case ZodFirstPartyTypeKind.ZodArray:
-      return parseArrayDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodUnion:
-    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
-      return parseUnionDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodIntersection:
-      return parseIntersectionDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodTuple:
-      return parseTupleDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodRecord:
-      return parseRecordDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodLiteral:
-      return parseLiteralDef(def);
-    case ZodFirstPartyTypeKind.ZodEnum:
-      return parseEnumDef(def);
-    case ZodFirstPartyTypeKind.ZodNativeEnum:
-      return parseNativeEnumDef(def);
-    case ZodFirstPartyTypeKind.ZodNullable:
-      return parseNullableDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodOptional:
-      return parseOptionalDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodMap:
-      return parseMapDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodSet:
-      return parseSetDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodLazy:
-      return () => (def as any).getter()._def;
-    case ZodFirstPartyTypeKind.ZodPromise:
-      return parsePromiseDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodNaN:
-    case ZodFirstPartyTypeKind.ZodNever:
-      return parseNeverDef();
-    case ZodFirstPartyTypeKind.ZodEffects:
-      return parseEffectsDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodAny:
-      return parseAnyDef();
-    case ZodFirstPartyTypeKind.ZodUnknown:
-      return parseUnknownDef();
-    case ZodFirstPartyTypeKind.ZodDefault:
-      return parseDefaultDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodBranded:
-      return parseBrandedDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodReadonly:
-      return parseReadonlyDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodCatch:
-      return parseCatchDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodPipeline:
-      return parsePipelineDef(def, refs);
-    case ZodFirstPartyTypeKind.ZodFunction:
-    case ZodFirstPartyTypeKind.ZodVoid:
-    case ZodFirstPartyTypeKind.ZodSymbol:
-      return undefined;
-    default:
-      /* c8 ignore next */
-      return ((_: never) => undefined)(typeName);
-  }
-};
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.test.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.test.ts
deleted file mode 100644
index 33dd6c9..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.test.ts
+++ /dev/null
@@ -1,862 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { JSONSchema7 } from '@ai-sdk/provider';
-import { z } from 'zod/v3';
-import {
-  ignoreOverride,
-  jsonDescription,
-  PostProcessCallback,
-} from './options';
-import { zod3ToJsonSchema } from './zod3-to-json-schema';
-
-describe('zod3-to-json-schema', () => {
-  describe('override', () => {
-    it('the readme example', () => {
-      expect(
-        zod3ToJsonSchema(
-          z.object({
-            ignoreThis: z.string(),
-            overrideThis: z.string(),
-            removeThis: z.string(),
-          }),
-          {
-            override: (def, refs) => {
-              const path = refs.currentPath.join('/');
-
-              if (path === '#/properties/overrideThis') {
-                return {
-                  type: 'integer',
-                };
-              }
-
-              if (path === '#/properties/removeThis') {
-                return undefined;
-              }
-
-              // Important! Do not return `undefined` or void unless you want to remove the property from the resulting schema completely.
-              return ignoreOverride;
-            },
-          },
-        ),
-      ).toStrictEqual({
-        $schema: 'http://json-schema.org/draft-07/schema#',
-        type: 'object',
-        required: ['ignoreThis', 'overrideThis'],
-        properties: {
-          ignoreThis: {
-            type: 'string',
-          },
-          overrideThis: {
-            type: 'integer',
-          },
-        },
-        additionalProperties: false,
-      });
-    });
-  });
-
-  describe('postProcess', () => {
-    it('the readme example', () => {
-      const zodSchema = z.object({
-        myString: z.string().describe(
-          JSON.stringify({
-            title: 'My string',
-            description: 'My description',
-            examples: ['Foo', 'Bar'],
-          }),
-        ),
-        myNumber: z.number(),
-      });
-
-      // Define the callback to be used to process the output using the PostProcessCallback type:
-      const postProcess: PostProcessCallback = (
-        // The original output produced by the package itself:
-        jsonSchema,
-        // The ZodSchema def used to produce the original schema:
-        def,
-        // The refs object containing the current path, passed options, etc.
-        refs,
-      ) => {
-        if (!jsonSchema) {
-          return jsonSchema;
-        }
-
-        // Try to expand description as JSON meta:
-        if (jsonSchema.description) {
-          try {
-            jsonSchema = {
-              ...jsonSchema,
-              ...JSON.parse(jsonSchema.description),
-            };
-          } catch {}
-        }
-
-        // Make all numbers nullable:
-        if ('type' in jsonSchema! && jsonSchema.type === 'number') {
-          jsonSchema.type = ['number', 'null'];
-        }
-
-        // Add the refs path, just because
-        (jsonSchema as any).path = refs.currentPath;
-
-        return jsonSchema;
-      };
-
-      const jsonSchemaResult = zod3ToJsonSchema(zodSchema, {
-        postProcess,
-      });
-
-      expect(jsonSchemaResult).toStrictEqual({
-        $schema: 'http://json-schema.org/draft-07/schema#',
-        type: 'object',
-        required: ['myString', 'myNumber'],
-        properties: {
-          myString: {
-            type: 'string',
-            title: 'My string',
-            description: 'My description',
-            examples: ['Foo', 'Bar'],
-            path: ['#', 'properties', 'myString'],
-          },
-          myNumber: {
-            type: ['number', 'null'],
-            path: ['#', 'properties', 'myNumber'],
-          },
-        },
-        additionalProperties: false,
-        path: ['#'],
-      });
-    });
-
-    it('expanding description json', () => {
-      const zodSchema = z.string().describe(
-        JSON.stringify({
-          title: 'My string',
-          description: 'My description',
-          examples: ['Foo', 'Bar'],
-          whatever: 123,
-        }),
-      );
-
-      const jsonSchemaResult = zod3ToJsonSchema(zodSchema, {
-        postProcess: jsonDescription,
-      });
-
-      expect(jsonSchemaResult).toStrictEqual({
-        $schema: 'http://json-schema.org/draft-07/schema#',
-        type: 'string',
-        title: 'My string',
-        description: 'My description',
-        examples: ['Foo', 'Bar'],
-        whatever: 123,
-      });
-    });
-  });
-
-  it('should return the schema directly in the root if no name is passed', () => {
-    expect(zod3ToJsonSchema(z.any())).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-    } satisfies JSONSchema7);
-  });
-
-  it('should return the schema inside a named property in "definitions" if a name is passed', () => {
-    expect(zod3ToJsonSchema(z.any(), 'MySchema')).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: `#/definitions/MySchema`,
-      definitions: {
-        MySchema: {},
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should return the schema inside a named property in "$defs" if a name and definitionPath is passed in options', () => {
-    expect(
-      zod3ToJsonSchema(z.any(), { name: 'MySchema', definitionPath: '$defs' }),
-    ).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: `#/$defs/MySchema`,
-      $defs: {
-        MySchema: {},
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it("should not scrub 'any'-schemas from unions when strictUnions=false", () => {
-    expect(
-      zod3ToJsonSchema(
-        z.union([z.any(), z.instanceof(String), z.string(), z.number()]),
-        { strictUnions: false },
-      ),
-    ).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      anyOf: [{}, {}, { type: 'string' }, { type: 'number' }],
-    } satisfies JSONSchema7);
-  });
-
-  it("should scrub 'any'-schemas from unions when strictUnions=true", () => {
-    expect(
-      zod3ToJsonSchema(
-        z.union([z.any(), z.instanceof(String), z.string(), z.number()]),
-        { strictUnions: true },
-      ),
-    ).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      anyOf: [{ type: 'string' }, { type: 'number' }],
-    } satisfies JSONSchema7);
-  });
-
-  it("should scrub 'any'-schemas from unions when strictUnions=true in objects", () => {
-    expect(
-      zod3ToJsonSchema(
-        z.object({
-          field: z.union([
-            z.any(),
-            z.instanceof(String),
-            z.string(),
-            z.number(),
-          ]),
-        }),
-        { strictUnions: true },
-      ),
-    ).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      additionalProperties: false,
-      properties: {
-        field: { anyOf: [{ type: 'string' }, { type: 'number' }] },
-      },
-      type: 'object',
-    } satisfies JSONSchema7);
-  });
-
-  it('Definitions play nice with named schemas', () => {
-    const MySpecialStringSchema = z.string();
-    const MyArraySchema = z.array(MySpecialStringSchema);
-
-    const result = zod3ToJsonSchema(MyArraySchema, {
-      definitions: {
-        MySpecialStringSchema,
-        MyArraySchema,
-      },
-    });
-
-    expect(result).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      $ref: '#/definitions/MyArraySchema',
-      definitions: {
-        MySpecialStringSchema: { type: 'string' },
-        MyArraySchema: {
-          type: 'array',
-          items: {
-            $ref: '#/definitions/MySpecialStringSchema',
-          },
-        },
-      },
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to add name as title instead of as ref', () => {
-    expect(
-      zod3ToJsonSchema(z.string(), { name: 'hello', nameStrategy: 'title' }),
-    ).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'string',
-      title: 'hello',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use description', () => {
-    const parsedSchema = zod3ToJsonSchema(
-      z.string().describe('My neat string'),
-    );
-
-    expect(parsedSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'string',
-      description: 'My neat string',
-    } satisfies JSONSchema7);
-  });
-
-  it('should handle optional schemas with different descriptions', () => {
-    const recurringSchema = z.object({});
-    const zodSchema = z
-      .object({
-        p1: recurringSchema.optional().describe('aaaaaaaaa'),
-        p2: recurringSchema.optional().describe('bbbbbbbbb'),
-        p3: recurringSchema.optional().describe('ccccccccc'),
-      })
-      .describe('sssssssss');
-
-    const jsonSchema = zod3ToJsonSchema(zodSchema, {
-      $refStrategy: 'none',
-    });
-
-    expect(jsonSchema).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      additionalProperties: false,
-      description: 'sssssssss',
-      properties: {
-        p1: {
-          additionalProperties: false,
-          description: 'aaaaaaaaa',
-          properties: {},
-          type: 'object',
-        },
-        p2: {
-          additionalProperties: false,
-          description: 'bbbbbbbbb',
-          properties: {},
-          type: 'object',
-        },
-        p3: {
-          additionalProperties: false,
-          description: 'ccccccccc',
-          properties: {},
-          type: 'object',
-        },
-      },
-      type: 'object',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use superRefine', () => {
-    const schema = z.object({
-      test: z
-        .string()
-        .optional()
-        .superRefine(async (value, ctx) => {
-          await new Promise(resolve => setTimeout(resolve, 100));
-          if (value === 'fail') {
-            ctx.addIssue({
-              code: z.ZodIssueCode.custom,
-              message: 'This is a test error',
-            });
-          }
-        }),
-    });
-
-    const output = zod3ToJsonSchema(schema);
-
-    expect(output).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: { test: { type: 'string' } },
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use describe on arrays', () => {
-    const topicSchema = z.object({
-      topics: z
-        .array(
-          z.object({
-            topic: z.string().describe('The topic of the position'),
-          }),
-        )
-        .describe('An array of topics'),
-    });
-
-    const res = zod3ToJsonSchema(topicSchema);
-
-    expect(res).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      required: ['topics'],
-      properties: {
-        topics: {
-          type: 'array',
-          items: {
-            type: 'object',
-            required: ['topic'],
-            properties: {
-              topic: {
-                type: 'string',
-                description: 'The topic of the position',
-              },
-            },
-            additionalProperties: false,
-          },
-          description: 'An array of topics',
-        },
-      },
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use regex with error messages', () => {
-    const urlRegex =
-      /^((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www\.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%,/.\w\-_]*)?\??(?:[-+=&;%@.\w:()_]*)#?(?:[.!/\\\w]*))?)/;
-
-    const URLSchema = z
-      .string()
-      .min(1)
-      .max(1000)
-      .regex(urlRegex, { message: 'Please enter a valid URL' })
-      .brand('url');
-
-    const jsonSchemaJs = zod3ToJsonSchema(URLSchema, { errorMessages: true });
-    const jsonSchema = JSON.parse(JSON.stringify(jsonSchemaJs));
-
-    expect(jsonSchema).toStrictEqual({
-      type: 'string',
-      minLength: 1,
-      maxLength: 1000,
-      pattern:
-        '^((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=+$,\\w]+@)?[A-Za-z0-9.-]+|(?:www\\.|[-;:&=+$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[+~%,/.\\w\\-_]*)?\\??(?:[-+=&;%@.\\w:()_]*)#?(?:[.!/\\\\\\w]*))?)',
-      $schema: 'http://json-schema.org/draft-07/schema#',
-    } satisfies JSONSchema7);
-  });
-
-  it('should be possible to use lazy recursion @162', () => {
-    const A: any = z.object({
-      ref1: z.lazy(() => B),
-    });
-
-    const B = z.object({
-      ref1: A,
-    });
-
-    const result = zod3ToJsonSchema(A);
-
-    expect(result).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        ref1: {
-          type: 'object',
-          properties: {
-            ref1: {
-              $ref: '#',
-            },
-          },
-          required: ['ref1'],
-          additionalProperties: false,
-        },
-      },
-      required: ['ref1'],
-      additionalProperties: false,
-    } satisfies JSONSchema7);
-  });
-
-  it('should produce valid json schema for all parsers', () => {
-    enum nativeEnum {
-      'a',
-      'b',
-      'c',
-    }
-
-    const allParsersSchema = z
-      .object({
-        any: z.any(),
-        array: z.array(z.any()),
-        arrayMin: z.array(z.any()).min(1),
-        arrayMax: z.array(z.any()).max(1),
-        arrayMinMax: z.array(z.any()).min(1).max(1),
-        bigInt: z.bigint(),
-        boolean: z.boolean(),
-        date: z.date(),
-        default: z.any().default(42),
-        effectRefine: z.string().refine(x => x + x),
-        effectTransform: z.string().transform(x => !!x),
-        effectPreprocess: z.preprocess(x => {
-          try {
-            return JSON.stringify(x);
-          } catch {
-            return 'wahh';
-          }
-        }, z.string()),
-        enum: z.enum(['hej', 'svejs']),
-        intersection: z.intersection(z.string().min(1), z.string().max(4)),
-        literal: z.literal('hej'),
-        map: z.map(z.string().uuid(), z.boolean()),
-        nativeEnum: z.nativeEnum(nativeEnum),
-        never: z.never() as any,
-        null: z.null(),
-        nullablePrimitive: z.string().nullable(),
-        nullableObject: z.object({ hello: z.string() }).nullable(),
-        number: z.number(),
-        numberGt: z.number().gt(1),
-        numberLt: z.number().lt(1),
-        numberGtLt: z.number().gt(1).lt(1),
-        numberGte: z.number().gte(1),
-        numberLte: z.number().lte(1),
-        numberGteLte: z.number().gte(1).lte(1),
-        numberMultipleOf: z.number().multipleOf(2),
-        numberInt: z.number().int(),
-        objectPasstrough: z
-          .object({ foo: z.string(), bar: z.number().optional() })
-          .passthrough(),
-        objectCatchall: z
-          .object({ foo: z.string(), bar: z.number().optional() })
-          .catchall(z.boolean()),
-        objectStrict: z
-          .object({ foo: z.string(), bar: z.number().optional() })
-          .strict(),
-        objectStrip: z
-          .object({ foo: z.string(), bar: z.number().optional() })
-          .strip(),
-        promise: z.promise(z.string()),
-        recordStringBoolean: z.record(z.string(), z.boolean()),
-        recordUuidBoolean: z.record(z.string().uuid(), z.boolean()),
-        recordBooleanBoolean: z.record(z.boolean(), z.boolean()),
-        set: z.set(z.string()),
-        string: z.string(),
-        stringMin: z.string().min(1),
-        stringMax: z.string().max(1),
-        stringEmail: z.string().email(),
-        stringEmoji: z.string().emoji(),
-        stringUrl: z.string().url(),
-        stringUuid: z.string().uuid(),
-        stringRegEx: z.string().regex(new RegExp('abc')),
-        stringCuid: z.string().cuid(),
-        tuple: z.tuple([z.string(), z.number(), z.boolean()]),
-        undefined: z.undefined(),
-        unionPrimitives: z.union([
-          z.string(),
-          z.number(),
-          z.boolean(),
-          z.bigint(),
-          z.null(),
-        ]),
-        unionPrimitiveLiterals: z.union([
-          z.literal(123),
-          z.literal('abc'),
-          z.literal(null),
-          z.literal(true),
-          // z.literal(1n), // target es2020
-        ]),
-        unionNonPrimitives: z.union([
-          z.string(),
-          z.object({
-            foo: z.string(),
-            bar: z.number().optional(),
-          }),
-        ]),
-        unknown: z.unknown(),
-      })
-      .partial()
-      .default({ string: 'hello' })
-      .describe('watup');
-
-    expect(zod3ToJsonSchema(allParsersSchema)).toStrictEqual({
-      $schema: 'http://json-schema.org/draft-07/schema#',
-      type: 'object',
-      properties: {
-        any: {},
-        array: {
-          type: 'array',
-        },
-        arrayMin: {
-          type: 'array',
-          minItems: 1,
-        },
-        arrayMax: {
-          type: 'array',
-          maxItems: 1,
-        },
-        arrayMinMax: {
-          type: 'array',
-          minItems: 1,
-          maxItems: 1,
-        },
-        bigInt: {
-          type: 'integer',
-          format: 'int64',
-        },
-        boolean: {
-          type: 'boolean',
-        },
-        date: {
-          type: 'string',
-          format: 'date-time',
-        },
-        default: {
-          default: 42,
-        },
-        effectRefine: {
-          type: 'string',
-        },
-        effectTransform: {
-          type: 'string',
-        },
-        effectPreprocess: {
-          type: 'string',
-        },
-        enum: {
-          type: 'string',
-          enum: ['hej', 'svejs'],
-        },
-        intersection: {
-          allOf: [
-            {
-              type: 'string',
-              minLength: 1,
-            },
-            {
-              type: 'string',
-              maxLength: 4,
-            },
-          ],
-        },
-        literal: {
-          type: 'string',
-          const: 'hej',
-        },
-        map: {
-          type: 'array',
-          maxItems: 125,
-          items: {
-            type: 'array',
-            items: [
-              {
-                type: 'string',
-                format: 'uuid',
-              },
-              {
-                type: 'boolean',
-              },
-            ],
-            minItems: 2,
-            maxItems: 2,
-          },
-        },
-        nativeEnum: {
-          type: 'number',
-          enum: [0, 1, 2],
-        },
-        never: {
-          not: {},
-        },
-        null: {
-          type: 'null',
-        },
-        nullablePrimitive: {
-          type: ['string', 'null'],
-        },
-        nullableObject: {
-          anyOf: [
-            {
-              type: 'object',
-              properties: {
-                hello: {
-                  type: 'string',
-                },
-              },
-              required: ['hello'],
-              additionalProperties: false,
-            },
-            {
-              type: 'null',
-            },
-          ],
-        },
-        number: {
-          type: 'number',
-        },
-        numberGt: {
-          type: 'number',
-          exclusiveMinimum: 1,
-        },
-        numberLt: {
-          type: 'number',
-          exclusiveMaximum: 1,
-        },
-        numberGtLt: {
-          type: 'number',
-          exclusiveMinimum: 1,
-          exclusiveMaximum: 1,
-        },
-        numberGte: {
-          type: 'number',
-          minimum: 1,
-        },
-        numberLte: {
-          type: 'number',
-          maximum: 1,
-        },
-        numberGteLte: {
-          type: 'number',
-          minimum: 1,
-          maximum: 1,
-        },
-        numberMultipleOf: {
-          type: 'number',
-          multipleOf: 2,
-        },
-        numberInt: {
-          type: 'integer',
-        },
-        objectPasstrough: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              type: 'number',
-            },
-          },
-          required: ['foo'],
-          additionalProperties: true,
-        },
-        objectCatchall: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              type: 'number',
-            },
-          },
-          required: ['foo'],
-          additionalProperties: {
-            type: 'boolean',
-          },
-        },
-        objectStrict: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              type: 'number',
-            },
-          },
-          required: ['foo'],
-          additionalProperties: false,
-        },
-        objectStrip: {
-          type: 'object',
-          properties: {
-            foo: {
-              type: 'string',
-            },
-            bar: {
-              type: 'number',
-            },
-          },
-          required: ['foo'],
-          additionalProperties: false,
-        },
-        promise: {
-          type: 'string',
-        },
-        recordStringBoolean: {
-          type: 'object',
-          additionalProperties: {
-            type: 'boolean',
-          },
-        },
-        recordUuidBoolean: {
-          type: 'object',
-          additionalProperties: {
-            type: 'boolean',
-          },
-          propertyNames: {
-            format: 'uuid',
-          },
-        },
-        recordBooleanBoolean: {
-          type: 'object',
-          additionalProperties: {
-            type: 'boolean',
-          },
-        },
-        set: {
-          type: 'array',
-          uniqueItems: true,
-          items: {
-            type: 'string',
-          },
-        },
-        string: {
-          type: 'string',
-        },
-        stringMin: {
-          type: 'string',
-          minLength: 1,
-        },
-        stringMax: {
-          type: 'string',
-          maxLength: 1,
-        },
-        stringEmail: {
-          type: 'string',
-          format: 'email',
-        },
-        stringEmoji: {
-          type: 'string',
-          pattern: '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$',
-        },
-        stringUrl: {
-          type: 'string',
-          format: 'uri',
-        },
-        stringUuid: {
-          type: 'string',
-          format: 'uuid',
-        },
-        stringRegEx: {
-          type: 'string',
-          pattern: 'abc',
-        },
-        stringCuid: {
-          type: 'string',
-          pattern: '^[cC][^\\s-]{8,}$',
-        },
-        tuple: {
-          type: 'array',
-          minItems: 3,
-          maxItems: 3,
-          items: [
-            {
-              type: 'string',
-            },
-            {
-              type: 'number',
-            },
-            {
-              type: 'boolean',
-            },
-          ],
-        },
-        undefined: {
-          not: {},
-        },
-        unionPrimitives: {
-          type: ['string', 'number', 'boolean', 'integer', 'null'],
-        },
-        unionPrimitiveLiterals: {
-          type: ['number', 'string', 'null', 'boolean'],
-          enum: [123, 'abc', null, true],
-        },
-        unionNonPrimitives: {
-          anyOf: [
-            {
-              type: 'string',
-            },
-            {
-              type: 'object',
-              properties: {
-                foo: {
-                  type: 'string',
-                },
-                bar: {
-                  type: 'number',
-                },
-              },
-              required: ['foo'],
-              additionalProperties: false,
-            },
-          ],
-        },
-        unknown: {},
-      },
-      additionalProperties: false,
-      default: {
-        string: 'hello',
-      },
-      description: 'watup',
-    });
-  });
-});
diff --git a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts b/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts
deleted file mode 100644
index 8eb2c30..0000000
--- a/packages/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts
+++ /dev/null
@@ -1,93 +0,0 @@
-import { ZodSchema } from 'zod/v3';
-import { Options } from './options';
-import { parseDef } from './parse-def';
-import { JsonSchema7Type } from './parse-types';
-import { getRefs } from './refs';
-import { parseAnyDef } from './parsers/any';
-
-const zod3ToJsonSchema = (
-  schema: ZodSchema<any>,
-  options?: Partial<Options> | string,
-): JsonSchema7Type & {
-  $schema?: string;
-  definitions?: {
-    [key: string]: JsonSchema7Type;
-  };
-} => {
-  const refs = getRefs(options);
-
-  let definitions =
-    typeof options === 'object' && options.definitions
-      ? Object.entries(options.definitions).reduce(
-          (acc: { [key: string]: JsonSchema7Type }, [name, schema]) => ({
-            ...acc,
-            [name]:
-              parseDef(
-                schema._def,
-                {
-                  ...refs,
-                  currentPath: [...refs.basePath, refs.definitionPath, name],
-                },
-                true,
-              ) ?? parseAnyDef(),
-          }),
-          {},
-        )
-      : undefined;
-
-  const name =
-    typeof options === 'string'
-      ? options
-      : options?.nameStrategy === 'title'
-        ? undefined
-        : options?.name;
-
-  const main =
-    parseDef(
-      schema._def,
-      name === undefined
-        ? refs
-        : {
-            ...refs,
-            currentPath: [...refs.basePath, refs.definitionPath, name],
-          },
-      false,
-    ) ?? (parseAnyDef() as JsonSchema7Type);
-
-  const title =
-    typeof options === 'object' &&
-    options.name !== undefined &&
-    options.nameStrategy === 'title'
-      ? options.name
-      : undefined;
-
-  if (title !== undefined) {
-    main.title = title;
-  }
-
-  const combined: ReturnType<typeof zod3ToJsonSchema> =
-    name === undefined
-      ? definitions
-        ? {
-            ...main,
-            [refs.definitionPath]: definitions,
-          }
-        : main
-      : {
-          $ref: [
-            ...(refs.$refStrategy === 'relative' ? [] : refs.basePath),
-            refs.definitionPath,
-            name,
-          ].join('/'),
-          [refs.definitionPath]: {
-            ...definitions,
-            [name]: main,
-          },
-        };
-
-  combined.$schema = 'http://json-schema.org/draft-07/schema#';
-
-  return combined;
-};
-
-export { zod3ToJsonSchema };
diff --git a/packages/rsc/src/stream-ui/stream-ui.tsx b/packages/rsc/src/stream-ui/stream-ui.tsx
index 45b9f23..95da7dd 100644
--- a/packages/rsc/src/stream-ui/stream-ui.tsx
+++ b/packages/rsc/src/stream-ui/stream-ui.tsx
@@ -29,7 +29,6 @@ import {
   standardizePrompt,
 } from 'ai/internal';
 import { ReactNode } from 'react';
-import * as z3 from 'zod/v3';
 import * as z4 from 'zod/v4';
 import { createStreamableUI } from '../streamable-ui/create-streamable-ui';
 import { createResolvablePromise } from '../util/create-resolvable-promise';
@@ -45,9 +44,7 @@ type Renderer<T extends Array<any>> = (
   | Generator<Streamable, Streamable, void>
   | AsyncGenerator<Streamable, Streamable, void>;
 
-type RenderTool<
-  INPUT_SCHEMA extends z4.core.$ZodType | z3.Schema | Schema = any,
-> = {
+type RenderTool<INPUT_SCHEMA extends z4.core.$ZodType | Schema = any> = {
   description?: string;
   inputSchema: INPUT_SCHEMA;
   generate?: Renderer<
@@ -94,7 +91,7 @@ const defaultTextRenderer: RenderText = ({ content }: { content: string }) =>
  * `streamUI` is a helper function to create a streamable UI from LLMs.
  */
 export async function streamUI<
-  TOOLS extends { [name: string]: z4.core.$ZodType | z3.Schema | Schema } = {},
+  TOOLS extends { [name: string]: z4.core.$ZodType | Schema } = {},
 >({
   model,
   tools,
-- 
2.50.1 (Apple Git-155)

